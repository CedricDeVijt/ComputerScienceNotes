## 4.1 Introduction to Virtual Memory

### Concept of Virtual Memory

- Virtual memory enables processes to use more memory than physically available by storing parts of memory in secondary storage (swap space).
- Uses **paging** and **segmentation** to break memory into manageable units.

### Benefits of Virtual Memory

- Allows running of multiple processes simultaneously.
- Enables processes to use larger address spaces than available physical memory.

### Key Concepts

- **Logical Address:** Generated by the compiler, also known as a virtual address.
- **Physical Address:** The actual location in main memory.
- **Page Fault:** Occurs when a requested page is not in memory and must be fetched from secondary storage.

## 4.2 Memory Layout in Linux

### Virtual Memory Segments

- **Kernel Space:** Reserved for the operating system, usually the top portion of memory.
- **User Space Segments:**
  - **Stack:** Stores local variables and function call data, grows dynamically.
  - **Heap:** Allocates memory dynamically (e.g., `malloc` in C).
  - **Text Segment:** Stores executable code.
  - **Data Segment:** Divided into initialized and uninitialized data (BSS).

### Security Enhancements

- **Random Offsets:** Randomize segment locations to prevent predictable memory layouts.

## 4.3 Paging and Page Tables

### Page Table Organization

- **Role:** Maps virtual pages to physical frames.
- **Challenges:** Page tables can become very large, requiring optimization techniques.

### Multilevel Page Tables

- Splits page tables into multiple levels to reduce size.
- Only portions of the page table are loaded into memory.

### Inverted Page Tables

- Contains an entry for each physical frame rather than each virtual page.
- Uses **hashing** for efficient lookups.

### Translation Lookaside Buffer (TLB)

- A cache for page table entries to speed up address translation.
- **TLB Miss:** Falls back to the page table in memory.
- **TLB Flush:** Clears TLB entries on process switches.

## 4.4 Page Replacement Algorithms

### Overview

- Determines which page to replace when memory is full.
- **Goal:** Minimize page faults.

### Algorithms

- **Optimal (MIN):** Replaces the page not needed for the longest time. Theoretical benchmark.
- **Least Recently Used (LRU):** Replaces the least recently accessed page.
- **First In First Out (FIFO):** Replaces the oldest page in memory.
  - **Beladyâ€™s Anomaly:** More memory can sometimes increase page faults.
- **Clock Algorithm:** A practical alternative using a circular buffer and reference bits.

### Advanced Techniques

- **Segmented FIFO:** Combines FIFO with an additional buffer for better performance.
- **Page Buffering:** Keeps replaced pages in a secondary buffer for potential reuse.

## 4.5 Resident Set Management

### Fixed vs Variable Allocation

- **Fixed:** Each process has a predefined number of frames.
- **Variable:** Allows dynamic adjustment of frames per process.

### Working Set Model

- Tracks the set of pages actively used by a process.
- Helps decide which pages to retain or replace based on recent usage.

---

## Key Points to Remember

- **Virtual Memory:** Facilitates the execution of large processes by using secondary storage.
- **Paging:** Splits memory into fixed-size blocks for easier management.
- **Page Faults:** Handled by the operating system to fetch missing pages.
- **Page Tables:** Structures that map virtual addresses to physical frames.
- **TLB:** Enhances translation speed by caching page table entries.
- **Replacement Algorithms:** Determine which page to evict to minimize faults.
- **Resident Set Management:** Balances memory allocation between processes.
