### Vraag 1: PTIME en NP (5pt)

#### (a) (1.5pt) Wat betekent het als een taal A in NP zit?

**Betekenis van een taal $A \in \text{NP}$**:
Een taal $A \subseteq \Sigma^\*$ zit in de complexiteitsklasse **NP** (Niet-deterministische Polynomiale tijd) als er een polynomiale verifiër bestaat die kan controleren of een input $x$ tot $A$ behoort. Formeel:

- Er is een deterministische Turingmachine $V$ en een polynomiale functie $p$, zodanig dat voor elke input $x \in \Sigma^\*$:
  - Als $x \in A$, er een certificaat $c$ bestaat met lengte $|c| \leq p(|x|)$, zodat $V(x, c)$ aanvaardt in tijd $O(p(|x|))$.
  - Als $x \notin A$, geen certificaat $c$ bestaat zodat $V(x, c)$ aanvaardt.
- Intuïtief: Een probleem is in NP als een voorgestelde oplossing (certificaat) in polynomiale tijd kan worden geverifieerd.

**1. Verband tussen talen en Turingmachines**:

- Een taal $A$ is een verzameling strings over een alfabet $\Sigma$. Een Turingmachine $M$ beslist een taal $A$ als $M$ op input $x$:
  - Aanvaardt als $x \in A$.
  - Verwerpt als $x \notin A$.
- Voor NP wordt de taal $A$ niet direct beslist door een Turingmachine die $A$ oplost, maar door een verifiër die controleert of $x \in A$ gegeven een certificaat. Dit maakt NP-problemen efficiënt verifieerbaar, maar niet noodzakelijk efficiënt oplosbaar.

**2. Soort Turingmachines**:

- **Deterministische Turingmachine (DTM)**: Gebruikt als verifiër in de definitie van NP. De verifiër $V$ is een DTM die op input $(x, c)$ in polynomiale tijd beslist of $c$ een geldig certificaat is voor $x \in A$.
- **Niet-deterministische Turingmachine (NDTM)**: Een alternatieve karakterisering van NP is dat $A \in \text{NP}$ als er een NDTM bestaat die $A$ in polynomiale tijd beslist. Een NDTM "gokt" niet-deterministisch een certificaat en verifieert het, wat equivalent is aan de DTM-verifiër.

**3. Tijdscomplexiteit van deze machines**:

- **Voor de DTM-verifiër**: De tijdscomplexiteit is polynomiaal, d.w.z. $O(p(|x|))$, waarbij $p$ een polynoom is en $|x|$ de lengte van de input is. Dit betekent dat de verifiër in een aantal stappen werkt dat polynomiaal is in de inputgrootte.
- **Voor de NDTM**: De tijdscomplexiteit is gedefinieerd als de maximale lengte van een berekeningspad in de berekeningsboom van de NDTM. Voor $A \in \text{NP}$, is er een NDTM die in tijd $O(p(n))$ beslist, waarbij alle paden (aanvaardend of verwerpend) hoogstens $p(n)$ stappen nemen. De machine aanvaardt als minstens één pad aanvaardt.

#### (b) (1.5pt) Geef de formele definitie van polynomiale tijd reduceerbaarheid en NP-compleetheid. Beschrijf hoe deze worden gebruikt om $\text{PTIME} = \text{NP}$ of $\text{PTIME} \neq \text{NP}$ aan te tonen.

**Definitie van polynomiale tijd reduceerbaarheid**:
Een taal $A \subseteq \Sigma^_$ is polynomiaal reduceerbaar naar een taal $B \subseteq \Sigma^_$, genoteerd als $A \leq_p B$, als er een polynomiaal tijd berekenbare functie $f: \Sigma^_ \to \Sigma^_$ bestaat zodanig dat voor elke $w \in \Sigma^\*$:
$$
w \in A \iff f(w) \in B.
$$

- Dit betekent dat een instantie $w$ van $A$ in polynomiale tijd kan worden omgezet in een instantie $f(w)$ van $B$, waarbij het lidmaatschap van $w \in A$ overeenkomt met $f(w) \in B$.

**Definitie van NP-compleetheid**:
Een taal $A$ is **NP-compleet** als:

1. $A \in \text{NP}$: De taal is in NP (heeft een polynomiale verifiër).
2. $A$ is **NP-hard**: Elke taal $L \in \text{NP}$ is polynomiaal reduceerbaar naar $A$, d.w.z. $L \leq_p A$. Dit betekent dat $A$ minstens zo moeilijk is als elk probleem in NP.

**Gebruik om $\text{PTIME} = \text{NP}$ of $\text{PTIME} \neq \text{NP}$ aan te tonen**:

- **Polynomiale reduceerbaarheid**:
  - Reducties worden gebruikt om de relatieve moeilijkheid van problemen te vergelijken. Als $A \leq_p B$ en $B \in \text{PTIME}$, dan is $A \in \text{PTIME}$, omdat we $A$ kunnen oplossen door $f(w)$ te berekenen (polynomiaal) en dan $B$ op te lossen (polynomiaal).
  - Voor NP-compleetheid wordt reductie gebruikt om aan te tonen dat een probleem $A$ NP-hard is door te bewijzen dat een bekend NP-compleet probleem (zoals SAT) naar $A$ kan worden gereduceerd.
- **NP-compleetheid en $\text{P} = \text{NP}$**:
  - **Als $\text{PTIME} = \text{NP}$**: Dit kan worden aangetoond door een polynomiaal algoritme te vinden voor een NP-compleet probleem (bijv. SAT). Omdat elk probleem in NP naar een NP-compleet probleem kan worden gereduceerd in polynomiale tijd, zou een polynomiaal algoritme voor een NP-compleet probleem betekenen dat alle NP-problemen in PTIME oplosbaar zijn, dus $\text{NP} \subseteq \text{PTIME}$. Aangezien $\text{PTIME} \subseteq \text{NP}$, volgt $\text{PTIME} = \text{NP}$.
  - **Als $\text{PTIME} \neq \text{NP}$**: Dit kan worden aangetoond door te bewijzen dat minstens één NP-compleet probleem niet in PTIME zit. Omdat NP-complete problemen de moeilijkste in NP zijn, zou dit betekenen dat niet alle NP-problemen in PTIME zitten, dus $\text{NP} \nsubseteq \text{PTIME}$, en dus $\text{PTIME} \neq \text{NP}$.
- **Praktisch**: De vraag $\text{P} = \text{NP}$ blijft open, maar NP-complete problemen zoals SAT, 3SAT, en SUBSETSUM zijn cruciale testgevallen. Een polynomiaal algoritme voor een van deze problemen zou $\text{P} = \text{NP}$ bewijzen, terwijl een bewijs dat een NP-compleet probleem niet in PTIME zit $\text{P} \neq \text{NP}$ zou aantonen.

#### (c) (2pt) Beschrijf de formule voor “het (i, j)-de window is legaal” in $\phi\_{\text{move}}$ en argumenteer waarom deze formule van grootte $O(n^2 k)$ is.

**Context**:
In de Stelling van Cook-Levin wordt een taal $L \in \text{NP}$ gereduceerd naar SAT door een CNF-formule $\phi = \phi*{\text{cell}} \wedge \phi*{\text{start}} \wedge \phi*{\text{move}} \wedge \phi*{\text{accept}}$ te construeren die de berekening van een polynomiale verifiër $V$ simuleert. De formule $\phi\_{\text{move}}$ zorgt ervoor dat de overgangen tussen configuraties van $V$ geldig zijn volgens de transitiefunctie $\delta$.

**Formule voor “het (i, j)-de window is legaal”**:

- **Achtergrond**:
  - $V$ is een deterministische Turingmachine met een polynomiale tijdslimiet $p(n)$, waar $n$ de lengte van de input $x$ is.
  - De berekening wordt voorgesteld als een tabel van $p(n) \times p(n)$ cellen, waarbij rij $i$ (1 ≤ $i$ ≤ $p(n)$) de configuratie op tijd $i-1$ voorstelt, en kolom $j$ (1 ≤ $j$ ≤ $p(n)$) de tape-positie $j-1$ voorstelt.
  - Elke cel $(i, j)$ bevat een symbool uit het tape-alfabet $\Gamma$ of een toestand $q \in Q$ (als de kop op positie $j-1$ is op tijd $i-1$).
  - Een "window" rond positie $j$ op tijd $i$ omvat de cellen $(i, j-1), (i, j), (i, j+1)$ (de huidige positie en aangrenzende posities) en hun opvolgers $(i+1, j-1), (i+1, j), (i+1, j+1)$.
  - De transitiefunctie $\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$ bepaalt hoe de configuratie verandert: $\delta(q, a) = (q', b, d)$ betekent dat in toestand $q$, bij het lezen van symbool $a$, de machine naar toestand $q'$ gaat, symbool $b$ schrijft, en de kop beweegt naar links ($L$) of rechts ($R$).
- **Definitie van “het (i, j)-de window is legaal”**:
  - Voor elk tijdstip $i$ (1 ≤ $i$ ≤ $p(n)$) en positie $j$ (1 ≤ $j$ ≤ $p(n)$), wordt een clause geconstrueerd die ervoor zorgt dat de overgang van configuratie op tijd $i-1$ naar tijd $i$ consistent is met $\delta$.
  - Variabelen:
    - $x\_{i,j,a}$: Waar als cel $(i, j)$ symbool $a \in \Gamma$ bevat.
    - $q\_{i,j,q}$: Waar als cel $(i, j)$ toestand $q \in Q$ bevat (de kop is op positie $j-1$).
  - Een window is legaal als de inhoud van de cellen $(i+1, j-1), (i+1, j), (i+1, j+1)$ volgt uit $(i, j-1), (i, j), (i, j+1)$ volgens $\delta$. Formeel:
    - Als de kop niet op positie $j-1, j, j+1$ is op tijd $i-1$, blijven de symbolen op $(i+1, j-1), (i+1, j), (i+1, j+1)$ ongewijzigd.
    - Als de kop op positie $j$ is in toestand $q$ en symbool $a$ leest ($q*{i,j,q} \wedge x*{i,j,a}$), en $\delta(q, a) = (q', b, d)$, dan:
      - Schrijf $b$ op positie $j$: $x\_{i+1,j,b}$.
      - Verplaats de kop:
        - Als $d = R$, stel de nieuwe toestand op $(i+1, j+1)$: $q\_{i+1,j+1,q'}$.
        - Als $d = L$, stel de nieuwe toestand op $(i+1, j-1)$: $q\_{i+1,j-1,q'}$.
      - Andere posities (niet beïnvloed door de kop) behouden hun symbool.
  - De clause voor een legaal window is een conjunctie van implicaties die alle mogelijke combinaties van $(q, a, b, q', d)$ en aangrenzende symbolen afdwingen. Voor elke geldige overgang wordt een clause van de vorm:
    $$
    (q*{i,j,q} \wedge x*{i,j,a} \wedge x*{i,j-1,c} \wedge x*{i,j+1,d}) \to (x*{i+1,j,b} \wedge q*{i+1,j+d,q'} \wedge x*{i+1,j-1,c} \wedge x*{i+1,j+1,d})
   $$
    (waarbij $j+d$ betekent $j+1$ voor $d = R$, $j-1$ voor $d = L$) toegevoegd, uitgedrukt in CNF.
  - Ongeldige windows (die niet overeenkomen met $\delta$) worden uitgesloten door negaties van ongeldige combinaties.

**Grootte van $\phi\_{\text{move}}$**:

- **Aantal windows**: Er zijn $p(n) \times p(n)$ windows, omdat $i$ en $j$ elk van 1 tot $p(n)$ lopen. Aangezien $p(n)$ polynomiaal is in $n$, is het aantal windows $O(p(n)^2)$.
- **Grootte per window**:
  - Het aantal mogelijke overgangen is afhankelijk van $|Q| \times |\Gamma|$, en het aantal aangrenzende symbolen is $|\Gamma|^2$ (voor posities $j-1, j+1$).
  - Voor elke overgang $\delta(q, a) = (q', b, d)$, wordt een constante grootte clause gegenereerd (typisch 6-8 literals, afhankelijk van de precieze codering).
  - Aangezien $|Q|$ en $|\Gamma|$ constant zijn (afhankelijk van de machine $V$), is de grootte van de clauses per window $O(1)$.
- **Totale grootte**:
  - Aantal clauses: $O(p(n)^2)$ windows × $O(1)$ clauses per window = $O(p(n)^2)$.
  - Aantal literals: Elke clause heeft een constante grootte, dus de totale grootte van $\phi\_{\text{move}}$ is $O(p(n)^2)$.
- **Relatie met $n^2 k$**:
  - In de vraag wordt $n^2 k$ genoemd, waarbij $n$ de inputgrootte is en $k$ mogelijk verwijst naar een constante of een parameter van de machine (bijv. $|Q|$ of $|\Gamma|$). Aangezien $p(n)$ polynomiaal is, is $p(n)^2 = O(n^{2d})$ voor een constante $d$, en als $k$ constant is, is $O(p(n)^2) = O(n^{2d} \cdot k)$ voor een passende $k$. In de context van Cook-Levin is $k$ vaak een constante (bijv. grootte van het alfabet), dus $O(n^2 k)$ is consistent met $O(p(n)^2)$.

**Conclusie**: De formule voor een legaal window dwingt geldige overgangen af volgens $\delta$, en de totale grootte van $\phi\_{\text{move}}$ is $O(n^2 k)$ door het aantal windows en de constante grootte per clause.

### Vraag 2: SUBSETSUM (5pt)

#### (a) (1pt) Beschrijf het SUBSETSUM probleem en toon aan dat SUBSETSUM in NP zit door middel van een polynomiale verifiër.

**Beschrijving van SUBSETSUM**:
Het SUBSETSUM-probleem is gedefinieerd als:
$$
\text{SUBSETSUM} = \{ \langle S, t \rangle \mid S = \{x*1, \ldots, x_k\} \text{ is een multiset van natuurlijke getallen, en er bestaat een deel-multiset } T \subseteq S \text{ zodat } \sum*{y \in T} y = t \}.
$$
Het vraagt of er een subset van $S$ bestaat waarvan de som precies $t$ is.

**Bewijs dat SUBSETSUM ∈ NP**:

- **Certificaat**: Het certificaat $c$ is een deel-multiset $T \subseteq S$, voorgesteld als een lijst van elementen of een binaire vector die aangeeft welke elementen in $T$ zitten.
- **Verifiër V**:
  1. Input: $\langle S, t \rangle$ en certificaat $c$ (deel-multiset $T$).
  2. Controleer of $T \subseteq S$ (elk element in $T$ komt voor in $S$).
  3. Bereken de som $\sum\_{y \in T} y$.
  4. Als de som gelijk is aan $t$, aanvaard; anders verwerp.
- **Tijdscomplexiteit**:
  - **Inputgrootte**: $n = O(k \log (\max\{x_i, t\}))$, waar $k$ het aantal elementen in $S$ is.
  - **Stap 2**: Controleer $T \subseteq S$: $O(k)$.
  - **Stap 3**: Som van $|T| \leq k$ getallen: $O(k \log (\max x_i)) = O(n)$.
  - **Totaal**: $O(n)$, polynomiaal.
- **Correctheid**:
  - Als $\langle S, t \rangle \in \text{SUBSETSUM}$, bestaat er een $T \subseteq S$ met $\sum\_{y \in T} y = t$, en $V(\langle S, t \rangle, T)$ aanvaardt.
  - Als $\langle S, t \rangle \notin \text{SUBSETSUM}$, is er geen $T$ met $\sum\_{y \in T} y = t$, en $V$ verwerpt.
- **Conclusie**: SUBSETSUM $\in \text{NP}$.

#### (b) (1.5pt) Beschrijf kort de reductie 3SAT ≤p SUBSETSUM en illustreer dit voor $\phi = (x_1 \vee \neg x_2 \vee \neg x_4) \wedge (x_2 \vee x_3 \vee x_5) \wedge (x_1 \vee x_4 \vee \neg x_6)$.

**Beschrijving van de reductie 3SAT ≤p SUBSETSUM**:
De reductie zet een 3SAT-formule $\phi$ met $n$ variabelen en $m$ clauses om in een SUBSETSUM-instantie $\langle S, t \rangle$, zodanig dat $\phi$ satisfiable is als en slechts als er een deel-multiset $T \subseteq S$ bestaat met $\sum\_{y \in T} y = t$.

- **Constructie**:
  - **Multiset $S$**:
    - Voor elke variabele $x_i$ (i = 1, ..., $n$): Voeg getallen $y_i$ (voor $x_i = 1$) en $z_i$ (voor $x_i = 0$) toe.
    - Voor elke clause $c_j$ (j = 1, ..., $m$): Voeg getallen $g_j, h_j$ toe als "slack".
  - **Getallen** (in decimale notatie):
    - $y_i$: Links een 1 op positie $i$, gevolgd door $n-i$ nullen; rechts een 1 op positie $n+j$ als $x_i \in c_j$, anders 0.
    - $z_i$: Links een 1 op positie $i$, gevolgd door $n-i$ nullen; rechts een 1 op positie $n+j$ als $\neg x_i \in c_j$, anders 0.
    - $g_j, h_j$: Een 1 op positie $n+j$, gevolgd door $m-j$ nullen.
  - **Doel $t$**: $n$ enen (voor variabelen) gevolgd door $m$ drieën (voor clauses).
  - **Intuïtie**: De eerste $n$ posities zorgen ervoor dat precies één van $y_i$ of $z_i$ wordt gekozen per variabele. De laatste $m$ posities zorgen ervoor dat elke clause minstens één waar literal heeft, met $g_j, h_j$ om de som tot 3 te vullen.

**Illustratie voor $\phi = (x_1 \vee \neg x_2 \vee \neg x_4) \wedge (x_2 \vee x_3 \vee x_5) \wedge (x_1 \vee x_4 \vee \neg x_6)$**:

- **Variabelen**: $x_1, x_2, x_3, x_4, x_5, x_6$ ($n = 6$).
- **Clauses** ($m = 3$):
  - $c_1 = (x_1 \vee \neg x_2 \vee \neg x_4)$
  - $c_2 = (x_2 \vee x_3 \vee x_5)$
  - $c_3 = (x_1 \vee x_4 \vee \neg x_6)$
- **Multiset $S$**:
  - Posities: 1 t/m 6 (variabelen), 7 t/m 9 (clauses).
  - **Getallen**:
    - $y_1$: 100000 101 (1 voor $c_1, c_3$) = 100000101
    - $z_1$: 100000 000 = 100000000
    - $y_2$: 010000 010 (1 voor $c_2$) = 010000010
    - $z_2$: 010000 100 (1 voor $c_1$) = 010000100
    - $y_3$: 001000 010 (1 voor $c_2$) = 001000010
    - $z_3$: 001000 000 = 001000000
    - $y_4$: 000100 001 (1 voor $c_3$) = 000100001
    - $z_4$: 000100 100 (1 voor $c_1$) = 000100100
    - $y_5$: 000010 010 (1 voor $c_2$) = 000010010
    - $z_5$: 000010 000 = 000010000
    - $y_6$: 000001 000 = 000001000
    - $z_6$: 000001 001 (1 voor $c_3$) = 000001001
    - $g_1, h_1$: 100 = 000000100
    - $g_2, h_2$: 010 = 000000010
    - $g_3, h_3$: 001 = 000000001
  - **Doel $t$**: 111111 333 = 111111333
- **SUBSETSUM-instantie**: $S = \{y_1, z_1, \ldots, y_6, z_6, g_1, h_1, g_2, h_2, g_3, h_3\}, t = 111111333$.

#### (c) (1.5pt) Toon de juistheid van de reductie 3SAT ≤p SUBSETSUM aan. Kies één richting.

**Gekozen richting**: Voorwaartse richting: Als $\phi$ satisfiable is, dan $\langle S, t \rangle \in \text{SUBSETSUM}$.

**Bewijs**:

- Stel dat $\phi$ satisfiable is, met een waarheidstoewijzing $\nu: \{x_1, \ldots, x_n\} \to \{0, 1\}$ die elke clause waar maakt.
- Construeer een deel-multiset $T \subseteq S$:
  - Voor elke variabele $x_i$:
    - Als $\nu(x_i) = 1$, voeg $y_i$ toe aan $T$.
    - Als $\nu(x_i) = 0$, voeg $z_i$ toe aan $T$.
  - Dit zorgt ervoor dat de som in de eerste $n$ posities precies $111\ldots1$ (n enen) is, omdat precies één van $y_i$ of $z_i$ per variabele wordt gekozen (elk draagt 1 bij op positie $i$).
  - Voor de laatste $m$ posities (clauses):
    - Elke clause $c_j$ heeft minstens één waar literal onder $\nu$.
    - Als $x_i \in c_j$ en $\nu(x_i) = 1$, draagt $y_i$ een 1 bij aan positie $n+j$.
    - Als $\neg x_i \in c_j$ en $\nu(x_i) = 0$, draagt $z_i$ een 1 bij aan positie $n+j$.
    - Elke clause $c_j$ krijgt dus 1, 2, of 3 enen van de $y_i$- en $z_i$-getallen.
    - Voeg nul, één, of twee van $\{g_j, h_j\}$ toe aan $T$ om de som op positie $n+j$ precies 3 te maken ($g_j$ en $h_j$ dragen elk 1 bij).
  - De som van $T$ is dan $t = 111\ldots1333\ldots3$.
- **Conclusie**: Als $\phi$ satisfiable is, bestaat er een $T \subseteq S$ met $\sum\_{y \in T} y = t$, dus $\langle S, t \rangle \in \text{SUBSETSUM}$.

#### (d) (1pt) Werkt de reductie voor SETSUBSETSUM? Zo niet, pas de reductie aan.

**Definitie van SETSUBSETSUM**:
In SETSUBSETSUM is $S$ een _verzameling_ (geen multiset), wat betekent dat elk element in $S$ uniek is en slechts één keer kan worden gekozen in de deelverzameling $T$.

**Werkt de reductie?**:
De reductie zoals beschreven in (b) werkt **niet** direct voor SETSUBSETSUM, omdat:

- $S$ bevat paren zoals $g_j, h_j$ die identiek zijn ($g_j = h_j$). In een verzameling zouden deze samenvallen tot één element, waardoor het onmogelijk wordt om twee "slack"-elementen te kiezen om de som in een clause-positie naar 3 te brengen.
- Bijvoorbeeld, als een clause $c_j$ slechts één waar literal heeft, moeten we twee slack-elementen ($g_j$ en $h_j$) toevoegen om de som naar 3 te krijgen, maar in een verzameling is er slechts één $g_j = h_j$.

**Aangepaste reductie voor 3SAT ≤p SETSUBSETSUM**:

- **Aanpassing**:
  - In plaats van twee identieke slack-elementen $g_j, h_j$, voeg voor elke clause $c_j$ drie unieke slack-elementen toe: $g_j^1, g_j^2, g_j^3$, elk met een 1 op positie $n+j$ en nullen elders.
    - $g_j^1 = g_j^2 = g_j^3 = 00\ldots010\ldots0$ (1 op positie $n+j$).
  - De rest van de constructie blijft hetzelfde:
    - $y_i, z_i$ zoals voorheen, voor variabelen en hun bijdrage aan clauses.
    - Doel $t$: $n$ enen gevolgd door $m$ drieën.
  - **Intuïtie**: De drie unieke slack-elementen per clause maken het mogelijk om 0, 1, 2, of 3 enen toe te voegen aan positie $n+j$, zodat de som precies 3 wordt, ongeacht het aantal waar literals (1, 2, of 3).
- **Correctheid**:
  - Als $\phi$ satisfiable is, kies $y_i$ of $z_i$ zoals in (c), en voeg voor elke clause $c_j$ voldoende slack-elementen $g_j^1, g_j^2, g_j^3$ toe (0 tot 3) om de som op positie $n+j$ naar 3 te brengen. Omdat $g_j^1, g_j^2, g_j^3$ uniek zijn, is dit mogelijk in een verzameling.
  - Omgekeerd, een oplossing voor SETSUBSETSUM induceert een consistente toewijzing, omdat de eerste $n$ posities nog steeds één $y_i$ of $z_i$ per variabele vereisen, en de clause-posities garanderen minstens één waar literal per clause.
- **Polynomiale tijd**: De nieuwe $S$ heeft $2n + 3m$ elementen (2 per variabele, 3 per clause), en de constructie blijft polynomiaal.

**Conclusie**: De originele reductie faalt voor SETSUBSETSUM vanwege dubbele elementen, maar de aangepaste reductie met unieke slack-elementen bewijst dat 3SAT $\leq_p$ SETSUBSETSUM.

## 1.1 Vraag 3: PSPACE en NPSPACE (5pt)

(a) (1pt) Formuleer de Stelling van Savitch en toon formeel aan dat hieruit volgt dat

PSPACE = NPSPACE. Wat kan je zeggen over de tijdscomplexiteit van problemen in

PSPACE?

(b) (1.5pt) Leg in woorden uit wat de cruciale ideëen zijn in het bewijs van de Stelling van

Savitch. Uit je antwoord moet duidelijk waarom deze vermijden dat de mogelijk expo-

nentieel grote configuratiegraaf moeten worden bewaard op de tape en op welke manier

exponentieel lange paden van de beginconfiguratie naar de aanvaardingsconfiguratie

kunnen worden gevonden.

(c) (1pt) Stel, je definieert PSPACE-compleetheid aan de hand van PSPACE-reducties. Toon

aan dat elke niet-triviale taal in PSPACE dan compleet zal zijn. Geef een formeel bewijs.

Waarom is dit niet gewenst?

(d) (1.5pt) Een voorbeeld van een PSPACE-compleet probeem is QBF. In het bewijs dat QBF

PSPACE-hard is wordt een een gekwantificeerde propositionele formule φC1,C2,t gebruikt

die waar is als en slechts dan de Turing machine M op input woord w van configuratie

C1 naar C2 kan gaan in maximaal t stappen. Stel dat we deze formules reeds hebben

voor t ≤k (per inductie). Wat is er mis met de volgende definitie voor t >k:

φC1,C2,t = ∃C[φC1,C,⌈t/2⌉∧φC,C2,⌈t/2⌉],

waar C, C1 and C2 configuraties representeren. En hoe wordt dit opgelost in het PSPACE-

hardheid bewijs van QBF? Leg uit en geef de juist definitie van φC1,C2,t voor t >k.

## 1.2 Vraag 4: LOGSPACE en NLOGSPACE (5pt)

(a) (2pt) Toon aan dat 2SAT in NLOGSPACE zit. Beschrijf het algoritme in voldoende detail

en argumenteer waarom het een NLOGSPACE algoritme is.

(b) (2pt) Geef de LOGSPACE-reductie f : Σ∗ →Σ∗ van PATH naar 2SAT en bewijs de

implicatie w ∈PATH ⇒f (w) ∈2SAT.

(c) (1pt) Is 2SAT ook NLOGSPACE-compleet? Leg uit.

EXAMEN: Algoritmen en Complexiteit
