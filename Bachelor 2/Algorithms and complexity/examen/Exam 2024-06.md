## 1 Vraag 1 PTIME en NP (4pt)

### a) (1pt) Toon aan dat de taal RELPRIME in PTIME zit door de tijdscomplexiteit van het algoritme van Euclides te analyseren.

De taal **RELPRIME** = {⟨x, y⟩ | x en y zijn relatief priem} zit in PTIME, omdat het algoritme van Euclides in polynomiale tijd bepaalt of de grootste gemene deler (gcd) van x en y gelijk is aan 1.

**Algoritme van Euclides**:

1. Herhaal totdat y = 0:
2. Laat x ← x mod y
3. Vervang x met y (en y met x)
4. Als x = 1, aanvaard; anders verwerp.

**Tijdscomplexiteitanalyse**:

- **Inputgrootte**: De input ⟨x, y⟩ heeft grootte $n = O(\text{max}\{\log x, \log_2 y\})$, omdat x en y binair worden voorgesteld.
- **Aantal iteraties**: In elke iteratie (stappen 2 en 3) halveert minstens één van de getallen x of y. Dit komt doordat na de modulo-operatie x < y wordt, en na het verwisselen y < x/2 of x < y/2. Het aantal iteraties is dus O(log(max{x, y})) = O(n).
- **Tijd per iteratie**: De modulo-operatie x mod y is polynomiaal in de lengte van de getallen, dus O(n²) voor getallen van lengte n (gebruikmakend van standaard algoritmen voor deling). De verwisseling en andere operaties zijn O(n).
- **Totale tijdscomplexiteit**: Aantal iteraties (O(n)) × tijd per iteratie (O(n²)) = O(n³).

Omdat O(n³) polynomiaal is, zit RELPRIME in PTIME.

### b) (1pt) Leg zo volledig mogelijk uit wat NP-complexiteit betekent. Leg in het bijzonder de notatie van reductie uit.

**NP-complexiteit**:
Een probleem behoort tot de complexiteitsklasse **NP** (Niet-deterministische Polynomiale tijd) als er een polynomiale verifiër bestaat die een oplossing voor het probleem in polynomiale tijd kan verifiëren. Formeel:

- Een taal $L \in NP$ als er een deterministische Turingmachine $V$ (de verifiër) bestaat, en een polynomiale functie p, zodat voor elke input x:
  - Als $x \in L$, er een certificaat c bestaat (met lengte |c| ≤ p(|x|)) zodat V(x, c) "aanvaardt" in polynomiale tijd.
  - Als $x \notin L$, geen certificaat c bestaat zodat V(x, c) aanvaardt.
- Intuïtief: NP-problemen zijn problemen waarvan een voorgestelde oplossing (certificaat) in polynomiale tijd kan worden gecontroleerd, maar het vinden van die oplossing kan exponentiële tijd kosten.

**Reductie**:
Een reductie is een manier om een probleem A om te zetten in een probleem B, zodat een oplossing voor B direct een oplossing voor A oplevert. In de context van NP wordt vaak gesproken van **polynomiale reductie** (notatie: $A ≤_p B$), wat betekent:

- Er bestaat een functie f, berekenbaar in polynomiale tijd, die een instantie x van probleem A omzet in een instantie f(x) van probleem B, zodat $x \in A \iff f(x) \in B$.
- Dit impliceert dat als B in polynomiale tijd oplosbaar is, A dat ook is.
- Reducties worden gebruikt om de relatieve moeilijkheid van problemen te vergelijken, bijvoorbeeld om aan te tonen dat een probleem NP-compleet is door te reduceren vanaf een bekend NP-compleet probleem.

### c) (2pt) Formuleer de stelling van Cook-Levin. Welke reductie wordt gebruikt in het bewijs van de stelling van Cook-Levin.

**Stelling van Cook-Levin**:
De stelling van Cook-Levin stelt dat het **SAT-probleem** (Satisfiability van propositionele formules in conjunctieve normaalvorm, CNF) **NP-compleet** is. Dit betekent:

1. $SAT \in NP$.
2. Elk probleem in $NP$ kan in polynomiale tijd worden gereduceerd naar $SAT$ ($SAT$ is $NP$-hard).

**Formulering**:

- $SAT = \{⟨\phi⟩ | \phi \text{ is een propositionele formule in CNF die satisfiable is}\}$.
- De stelling beweert dat $SAT$ in $NP$ zit en dat voor elke taal $L \in NP$, er een polynomiale reductie bestaat van L naar $SAT$.

**Reductie in het bewijs**:
Het bewijs van de stelling van Cook-Levin gebruikt een reductie van een willekeurige taal $L \in NP$ naar $SAT$.

## 2 Vraag 2 Subsetsum (4pt)

### a) (2pt) Definieer formeel wat een polynomiale verifiër is, beschrijf het SUBSETSUM probleem én toon aan dat SUBSETSUM in NP zit door middel van een polynomiale verifiër.

**Definitie van een polynomiale verifiër**:
Een polynomiale verifiër voor een taal $L$ is een deterministische Turingmachine $V$ met twee inputs: een input $x$ en een certificaat $c$, zodanig dat:

- Er een polynomiale functie $p$ bestaat, zodat $V(x, c)$ in tijd $O(p(|x|))$ beslist of $x \in L$.
- Voor $x \in L$ bestaat er een certificaat c (met $|c| \leq p(|x|)$) zodat $V(x, c)$ aanvaardt.
- Voor $x \notin L$ bestaat er geen certificaat $c$ zodat $V(x, c)$ aanvaardt.

**Beschrijving van SUBSETSUM**:
Het SUBSETSUM-probleem wordt gedefinieerd als:

- $SUBSETSUM = \{⟨S, t⟩ | S = \{x_1, \dots , x_k\}\}$ is een multiset van natuurlijke getallen, en er bestaat een deel-multiset $T \subseteq S$ zodat $\sum\limits_{y \in T} y = t$.
- Intuïtief: Gegeven een verzameling getallen $S$ en een doelgetal $t$, bestaat er een subset van $S$ waarvan de som precies $t$ is?

**Bewijs dat SUBSETSUM in NP zit**:
We tonen aan dat SUBSETSUM in NP zit door een polynomiale verifiër te construeren.

- **Certificaat**: Het certificaat c is een deel-multiset T ⊆ S, voorgesteld als een lijst van elementen uit S (of een binaire vector die aangeeft welke elementen in T zitten).
- **Verifiër V**:
  1. Input: ⟨S, t⟩ en certificaat c (de deel-multiset T).
  2. Controleer of T een geldige deel-multiset van S is (elk element in T moet in S voorkomen, met juiste veelvoud).
  3. Bereken de som ∑\_{y∈T} y.
  4. Als de som gelijk is aan t, aanvaard; anders verwerp.
- **Tijdscomplexiteit**:
  - Controle van T als deel-multiset: O(k), waar k het aantal elementen in S is (vergelijk elementen in T met S).
  - Berekening van de som: O(k) voor het optellen van k getallen (aannemende dat elk getal in S polynomiaal is in de inputgrootte, d.w.z. log xᵢ = O(n)).
  - De grootte van de input is n = O(k log(max{xᵢ, t})), dus de verifiër werkt in polynomiale tijd O(n).
- **Correctheid**:
  - Als ⟨S, t⟩ ∈ SUBSETSUM, bestaat er een T ⊆ S met ∑\_{y∈T} y = t, en V(⟨S, t⟩, T) aanvaardt.
  - Als ⟨S, t⟩ ∉ SUBSETSUM, is er geen T ⊆ S met ∑\_{y∈T} y = t, en V(⟨S, t⟩, c) verwerpt voor elk certificaat c.
- **Conclusie**: Omdat er een polynomiale verifiër bestaat, zit SUBSETSUM in NP.

### b) (2pt) Beschrijf de reductie 3SAT ≤p SUBSETSUM in het algemeen én illustreer de reductie voor $\phi$ = (x₁ ∨ x₂ ∨ x₃) ∧ (¬x₂ ∨ x₃ ∨ x₄) ∧ (x₁ ∨ ¬x₂ ∨ ¬x₄). Toon aan in het algemeen dat een oplossing van het verkregen SUBSETSUM probleem overeenkomt met het satisfieerbaar zijn van het propositionele formule waarvan men vertrekt.

**Algemene beschrijving van de reductie 3SAT ≤p SUBSETSUM**:
De reductie zet een 3CNF-formule $\phi$ met $l$ variabelen x₁, ..., xₗ en $k$ clauses $c_1, \dots, c_k$ om in een SUBSETSUM-instantie $⟨S, t⟩$, zodanig dat $\phi$ satisfiable is als en slechts als er een deel-multiset $T \subseteq S$ bestaat met $\sum\limits_{y∈T} y = t$.

- **Constructie**:
  - **Multiset S**:
    - Voor elke variabele xᵢ (i = 1, ..., ℓ): Voeg getallen yᵢ en zᵢ toe om xᵢ = 1 (waar) respectievelijk xᵢ = 0 (onwaar) te vertegenwoordigen.
    - Voor elke clause cⱼ (j = 1, ..., k): Voeg getallen gⱼ en hⱼ toe om "slack" te creëren voor clauses.
  - **Getallen in S** (in decimale notatie):
    - yᵢ: Links een 1 op positie i, gevolgd door ℓ-i nullen; rechts een 1 op positie j als xᵢ in clause cⱼ zit, anders 0.
    - zᵢ: Links een 1 op positie i, gevolgd door ℓ-i nullen; rechts een 1 op positie j als ¬xᵢ in clause cⱼ zit, anders 0.
    - gⱼ, hⱼ: Een 1 op positie ℓ+j, gevolgd door k-j nullen (identiek voor gⱼ en hⱼ).
  - **Doel t**: Bestaat uit ℓ enen (voor variabelen) gevolgd door k drieën (voor clauses).
  - **Intuïtie**:
    - De eerste ℓ posities zorgen ervoor dat precies één van yᵢ of zᵢ wordt gekozen per variabele (voor een consistente toewijzing).
    - De laatste k posities zorgen ervoor dat elke clause minstens één waar literal heeft (som = 3), met gⱼ en hⱼ als "opvulling" om van 1 of 2 naar 3 te gaan.
- **Polynomiale tijd**: De constructie van S en t vereist O(ℓk) operaties (voor het vullen van de tabellen), wat polynomiaal is in de grootte van $\phi$.

**Illustratie voor $\phi$ = (x₁ ∨ x₂ ∨ x₃) ∧ (¬x₂ ∨ x₃ ∨ x₄) ∧ (x₁ ∨ ¬x₂ ∨ ¬x₄)**:

- **Variabelen**: x₁, x₂, x₃, x₄ (ℓ = 4).
- **Clauses**:
  - c₁ = (x₁ ∨ x₂ ∨ x₃)
  - c₂ = (¬x₂ ∨ x₃ ∨ x₄)
  - c₃ = (x₁ ∨ ¬x₂ ∨ ¬x₄)
    (k = 3).
- **Constructie van S**:
  - **Tabel** (decimale notatie, zoals op pagina 127-128):
    - Posities: 1, 2, 3, 4 (voor variabelen), 5, 6, 7 (voor clauses c₁, c₂, c₃).
    - y₁: Links 1000 (1 op positie 1); rechts 101 (1 voor c₁, c₃ waar x₁ voorkomt).
      - y₁ = 1000101
    - z₁: Links 1000; rechts 000 (¬x₁ komt niet voor).
      - z₁ = 1000000
    - y₂: Links 0100; rechts 100 (1 voor c₁ waar x₂ voorkomt).
      - y₂ = 0100100
    - z₂: Links 0100; rechts 011 (1 voor c₂, c₃ waar ¬x₂ voorkomt).
      - z₂ = 0100011
    - y₃: Links 0010; rechts 110 (1 voor c₁, c₂ waar x₃ voorkomt).
      - y₃ = 0010110
    - z₃: Links 0010; rechts 000 (¬x₃ komt niet voor).
      - z₃ = 0010000
    - y₄: Links 0001; rechts 010 (1 voor c₂ waar x₄ voorkomt).
      - y₄ = 0001010
    - z₄: Links 0001; rechts 001 (1 voor c₃ waar ¬x₄ voorkomt).
      - z₄ = 0001001
    - g₁, h₁: 100 (1 op positie 5).
      - g₁ = h₁ = 0000100
    - g₂, h₂: 010 (1 op positie 6).
      - g₂ = h₂ = 0000010
    - g₃, h₃: 001 (1 op positie 7).
      - g₃ = h₃ = 0000001
  - **Doel t**: ℓ enen (1111) gevolgd door k drieën (333).
    - t = 1111333
- **SUBSETSUM-instantie**: S = {y₁, z₁, y₂, z₂, y₃, z₃, y₄, z₄, g₁, h₁, g₂, h₂, g₃, h₃}, t = 1111333.

**Algemene correctheid van de reductie**:
We tonen aan dat $\phi$ satisfiable is ⇔ ⟨S, t⟩ ∈ SUBSETSUM.

- **Voorwaartse richting ($\phi$ satisfiable ⇒ ⟨S, t⟩ ∈ SUBSETSUM)**:
  - Stel dat $\phi$ satisfiable is, met een toewijzing ν: {x₁, ..., xₗ} → {0, 1} die $\phi$ waar maakt.
  - Construeer T ⊆ S:
    - Voor elke variabele xᵢ:
      - Als ν(xᵢ) = 1, voeg yᵢ toe aan T.
      - Als ν(xᵢ) = 0, voeg zᵢ toe aan T.
    - Dit zorgt ervoor dat de som in de eerste ℓ posities precies 111...1 (ℓ enen) is, omdat precies één van yᵢ of zᵢ per variabele wordt gekozen (elk draagt 1 bij op positie i).
    - Voor de laatste k posities (clauses):
      - Omdat ν $\phi$ waar maakt, heeft elke clause cⱼ minstens één waar literal.
      - Als xᵢ in cⱼ zit en ν(xᵢ) = 1, draagt yᵢ een 1 bij aan positie ℓ+j.
      - Als ¬xᵢ in cⱼ zit en ν(xᵢ) = 0, draagt zᵢ een 1 bij aan positie ℓ+j.
      - Elke clause cⱼ krijgt dus 1, 2, of 3 enen van de yᵢ’s en zᵢ’s (afhankelijk van het aantal waar literals).
      - Voeg nul, één, of twee van {gⱼ, hⱼ} toe aan T om de som op positie ℓ+j precies 3 te maken (gⱼ en hⱼ dragen elk 1 bij).
    - De som van T is dan t = 111...1333...3.
  - Dus, ⟨S, t⟩ ∈ SUBSETSUM.
- **Omgekeerde richting (⟨S, t⟩ ∈ SUBSETSUM ⇒ $\phi$ satisfiable)**:
  - Stel dat er een T ⊆ S bestaat met ∑\_{x∈T} x = t.
  - **Eerste ℓ posities**:
    - De som is 111...1, wat betekent dat precies één van yᵢ of zᵢ per variabele in T zit (anders zou de som >1 of <1 zijn op positie i, omdat gⱼ en hⱼ geen bijdrage leveren aan deze posities).
    - Definieer ν(xᵢ) = 1 als yᵢ ∈ T, anders ν(xᵢ) = 0 (als zᵢ ∈ T).
  - **Laatste k posities**:
    - De som is 333...3, wat betekent dat elke positie ℓ+j precies 3 draagt.
    - Omdat gⱼ en hⱼ elk 1 bijdragen, en er hoogstens twee (gⱼ, hⱼ) zijn, moet minstens één yᵢ of zᵢ een 1 bijdragen aan positie ℓ+j.
    - Dit betekent dat voor elke clause cⱼ minstens één literal waar is onder ν:
      - Als yᵢ ∈ T en xᵢ in cⱼ, dan is ν(xᵢ) = 1 en is xᵢ waar.
      - Als zᵢ ∈ T en ¬xᵢ in cⱼ, dan is ν(xᵢ) = 0 en is ¬xᵢ waar.
    - Dus, elke clause cⱼ is waar onder ν.
  - Dus, ν maakt $\phi$ satisfiable.
  - **Conclusie**: De reductie is correct, want $\phi$ is satisfiable ⇔ ⟨S, t⟩ ∈ SUBSETSUM.

**Voorbeeldverificatie** (optioneel, ter illustratie):
Voor $\phi$ = (x₁ ∨ x₂ ∨ x₃) ∧ (¬x₂ ∨ x₃ ∨ x₄) ∧ (x₁ ∨ ¬x₂ ∨ ¬x₄), een satisfiable toewijzing is ν(x₁) = 1, ν(x₂) = 0, ν(x₃) = 1, ν(x₄) = 0:

- T = {y₁, z₂, y₃, z₄, g₂, h₂, g₃, h₃}:
  - y₁ = 1000101, z₂ = 0100011, y₃ = 0010110, z₄ = 0001001.
  - g₂ = h₂ = 0000010, g₃ = h₃ = 0000001.
  - Som: 1111333 (controleer per positie).
- Dit komt overeen met een oplossing voor SUBSETSUM, en ν maakt $\phi$ waar.

## 3 Vraag 3 PSPACE en NPSPACE (4pt)

### a) (1pt) Formuleer de stelling van Savitch en toon aan wat hieruit volgt door de klassen PSPACE en NPSPACE. Laat zien dat je de definities van deze complexiteitsklassen kent.

**Stelling van Savitch**: Voor elke niet-deterministische Turingmachine die een probleem oplost in ruimte $S(n) \geq \log n$, bestaat er een deterministische Turingmachine die hetzelfde probleem oplost in ruimte $O(S(n)^2)$.

**Definities**:

- **PSPACE**: De klasse van problemen die door een deterministische Turingmachine kunnen worden opgelost met polynomiaal begrensde ruimte, d.w.z. $O(n^k)$ voor een constante $k$.
- **NPSPACE**: De klasse van problemen die door een niet-deterministische Turingmachine kunnen worden opgelost met polynomiaal begrensde ruimte.

**Gevolg van Savitch’s stelling**:
Uit de stelling volgt dat $\text{NPSPACE} \subseteq \text{PSPACE}$. Dit komt doordat een niet-deterministische Turingmachine met ruimte $S(n)$ (polynomiaal) kan worden gesimuleerd door een deterministische Turingmachine met ruimte $O(S(n)^2)$, wat nog steeds polynomiaal is. Dus: $\text{NPSPACE} = \text{PSPACE}$.

**Toelichting**:

- De simulatie van een niet-deterministische machine door een deterministische machine gebruikt een divide-and-conquer-aanpak (reachability in een configuratiegraaf), wat leidt tot een kwadratische toename in ruimtegebruik.
- Dit resultaat is opmerkelijk omdat het aantoont dat niet-determinisme in ruimtecomplexiteit geen voordeel biedt voor polynomiale ruimte, in tegenstelling tot tijdcomplexiteit (waar $\text{P} \neq \text{NP}$ nog open is).

### b) (1pt) Is $NP \subseteq PSPACE$ of $PSPACE \subseteq NP$? Wat kan je verder zeggen over de tijdscomplexiteit van problemen in PSPACE? Leg uit.

**Relatie tussen NP en PSPACE**:

- **NP ⊆ PSPACE**: Dit is waar. Problemen in NP (niet-deterministische polynomiale tijd) kunnen worden opgelost in PSPACE (polynomiale ruimte). Een niet-deterministische Turingmachine die in polynomiale tijd werkt, gebruikt slechts polynomiale ruimte, omdat de ruimtebehoefte wordt bepaald door de lengte van de berekening en de grootte van de invoer. Daarom vallen alle NP-problemen binnen PSPACE.
- **PSPACE ⊆ NP**: Dit is niet waar, tenzij P = NP = PSPACE, wat onwaarschijnlijk is maar nog niet bewezen. PSPACE bevat problemen die mogelijk meer dan niet-deterministische polynomiale tijd vereisen, zoals bepaalde problemen die exponentiële tijd maar polynomiale ruimte nodig hebben. Een voorbeeld is het oplossen van gekwantificeerde booleaanse formules (QBF), wat PSPACE-compleet is en waarschijnlijk niet in NP ligt.

**Tijdscomplexiteit van problemen in PSPACE**:

- PSPACE omvat problemen die kunnen worden opgelost met een polynomiale hoeveelheid geheugen, ongeacht de tijd. Dit betekent dat de tijdscomplexiteit van PSPACE-problemen zeer groot kan zijn, vaak exponentieel (bijv. $O(2^n)$) of zelfs hoger, afhankelijk van het probleem.
- PSPACE-compleet problemen, zoals QBF of bepaalde bordspelen (bijv. veralgemeende schaakproblemen), vereisen in het slechtste geval exponentiële tijd, omdat ze alle beschikbare polynomiale ruimte kunnen benutten in een berekening die veel stappen vereist.
- Hoewel PSPACE problemen bevat die in polynomiale tijd oplosbaar zijn (bijv. P ⊆ PSPACE), zijn de meeste PSPACE-problemen, vooral de complete problemen, in de praktijk niet efficiënt oplosbaar (geen polynomiale tijd) tenzij P = PSPACE.

### c) (2pt) In het bewijs van de stelling van Savitch laten we de procedure ISBEREIKBAAR, los op de configuratie graaf van de uitvoering van een Turingmachine M op een input woord w. Antwoord de volgende vragen:

#### Vul de volgende pseudo-code verder aan:

```
ISBEREIKBAAR(c1, c2, t)
Als t = 1,
  Als c1 = c2 of c1 heeft een overgang naar c2 in 1 stap aanvaard.
  Anders, verwerp.
Als t > 1 dan voor elke cm in de configuratiegraaf:
  Voer ISBEREIKBAAR(c1, cm, t/2)
  Voer ISBEREIKBAAR(cm, c2, t/2)
Als beiden aanvaarden, aanvaard. Als nog niet aanvaard, verwerp.
```

#### Hoe wordt uiteindelijk bereikbaar gebruikt in het bewijs van de stelling van Savitch? Leg uit dat het hergebruik van plaats cruciaal is.

In het bewijs van Savitch's stelling wordt de procedure **ISBEREIKBAAR** gebruikt om te bepalen of er een pad bestaat tussen twee configuraties in de configuratiegraaf van een Turingmachine $M$ op inputwoord $w$. Deze graaf vertegenwoordigt alle mogelijke toestandsovergangen van $M$, en **ISBEREIKBAAR** controleert of een eindconfiguratie bereikbaar is vanuit de startconfiguratie binnen een bepaald aantal stappen.

Hoe wordt ISBEREIKBAAR gebruikt?

1. **Doel**: Savitch's stelling bewijst dat een niet-deterministische Turingmachine (NTM) met ruimtecomplexiteit $S(n)$ gesimuleerd kan worden door een deterministische Turingmachine (DTM) met ruimtecomplexiteit $O(S(n)^2)$. **ISBEREIKBAAR** is een kernonderdeel van deze simulatie.
2. **Werking**: De procedure **ISBEREIKBAAR($c_1$, $c_2$, k)** bepaalt of configuratie $c_2$ bereikbaar is vanuit $c_1$ in maximaal $2^k$ stappen. Dit doet het door recursief te controleren of er een tussentijdse configuratie $c_m$ bestaat zodanig dat $c_1 \to c_m$ en $c_m \to c_2$ in maximaal $2^{k-1}$ stappen.
3. **Recursieve aanpak**: Door de graaf op te delen in kleinere subproblemen (halvering van het aantal stappen), wordt het probleem opgelost met een divide-and-conquer-strategie.

Waarom is hergebruik van plaats cruciaal?

- **Ruimte-efficiëntie**: **ISBEREIKBAAR** hergebruikt dezelfde geheugenruimte voor elke recursieve aanroep door oude tussentijdse configuraties te overschrijven. Dit zorgt ervoor dat de totale ruimtebehoefte slechts $O(\log(2^{S(n)})) = O(S(n))$ is per recursieniveau.
- **Recursiediepte**: De recursie heeft een diepte van $O(S(n))$, omdat het aantal stappen in de configuratiegraaf exponentieel is ($2^{O(S(n))}$). Door ruimte te hergebruiken, blijft de totale ruimte $O(S(n)) \times O(S(n)) = O(S(n)^2)$, wat overeenkomt met de stelling.
- **Cruciaal voor bewijs**: Zonder hergebruik van ruimte zou elke recursieve aanroep extra geheugen vereisen, wat de ruimtecomplexiteit boven $O(S(n)^2)$ zou drijven, waardoor de simulatie niet meer efficiënt zou zijn.

Kortom, **ISBEREIKBAAR** simuleert het niet-deterministische gedrag deterministisch, en het hergebruik van ruimte zorgt ervoor dat de simulatie binnen de vereiste $O(S(n)^2)$-grens blijft.

## 4 Vraag 4 NLOGSPACE (4pt)

### a) (2pt) Toon aan dat $\overline{2SAT}$ in NLOGSPACE zit. Beschrijf het algoritme in voldoende detail en argumenteer waarom het een NLOGSPACE algoritme is. Uit je antwoorden moet duidelijk zijn wat voor Turingmachines gebruikt worden. Ook nog, wat kan je zeggen over de plaatscomplexiteit van $2SAT$?

### b) (2pt) Formuleer de stelling van Immerman-Szelepcsényi. Leg uit hoe, in het bewijs van deze stelling, gegeven <G,s,t,c>, met G een gerichte graaf, s en t begin een eind knoop en c het aantal knopen bereikbaar uit s, beslist wordt dat er geen pad is van s naar t.
