## Vraag 1 PTIME en NP (4pt)

### a) (1pt) Toon aan dat de taal RELPRIME in PTIME zit door de tijdscomplexiteit van het algoritme van Euclides te analyseren.

De taal **RELPRIME** = {⟨x, y⟩ | x en y zijn relatief priem} zit in PTIME, omdat het algoritme van Euclides in polynomiale tijd bepaalt of de grootste gemene deler (gcd) van x en y gelijk is aan 1.

**Algoritme van Euclides**:

1. Herhaal totdat y = 0:
2. Laat x ← x mod y
3. Vervang x met y (en y met x)
4. Als x = 1, aanvaard; anders verwerp.

**Tijdscomplexiteitanalyse**:

- **Inputgrootte**: De input ⟨x, y⟩ heeft grootte $n = O(\text{max}\{\log x, \log_2 y\})$, omdat x en y binair worden voorgesteld.
- **Aantal iteraties**: In elke iteratie (stappen 2 en 3) halveert minstens één van de getallen x of y. Dit komt doordat na de modulo-operatie x < y wordt, en na het verwisselen y < x/2 of x < y/2. Het aantal iteraties is dus O(log(max{x, y})) = O(n).
- **Tijd per iteratie**: De modulo-operatie x mod y is polynomiaal in de lengte van de getallen, dus O(n²) voor getallen van lengte n (gebruikmakend van standaard algoritmen voor deling). De verwisseling en andere operaties zijn O(n).
- **Totale tijdscomplexiteit**: Aantal iteraties (O(n)) × tijd per iteratie (O(n²)) = O(n³).

Omdat O(n³) polynomiaal is, zit RELPRIME in PTIME.

### b) (1pt) Leg zo volledig mogelijk uit wat NP-complexiteit betekent. Leg in het bijzonder de notatie van reductie uit.

**NP-complexiteit**:
Een probleem behoort tot de complexiteitsklasse **NP** (Niet-deterministische Polynomiale tijd) als er een polynomiale verifiër bestaat die een oplossing voor het probleem in polynomiale tijd kan verifiëren. Formeel:

- Een taal $L \in NP$ als er een deterministische Turingmachine $V$ (de verifiër) bestaat, en een polynomiale functie p, zodat voor elke input x:
  - Als $x \in L$, er een certificaat c bestaat (met lengte |c| ≤ p(|x|)) zodat V(x, c) "aanvaardt" in polynomiale tijd.
  - Als $x \notin L$, geen certificaat c bestaat zodat V(x, c) aanvaardt.
- Intuïtief: NP-problemen zijn problemen waarvan een voorgestelde oplossing (certificaat) in polynomiale tijd kan worden gecontroleerd, maar het vinden van die oplossing kan exponentiële tijd kosten.

**Reductie**:
Een reductie is een manier om een probleem A om te zetten in een probleem B, zodat een oplossing voor B direct een oplossing voor A oplevert. In de context van NP wordt vaak gesproken van **polynomiale reductie** (notatie: $A ≤_p B$), wat betekent:

- Er bestaat een functie f, berekenbaar in polynomiale tijd, die een instantie x van probleem A omzet in een instantie f(x) van probleem B, zodat $x \in A \iff f(x) \in B$.
- Dit impliceert dat als B in polynomiale tijd oplosbaar is, A dat ook is.
- Reducties worden gebruikt om de relatieve moeilijkheid van problemen te vergelijken, bijvoorbeeld om aan te tonen dat een probleem NP-compleet is door te reduceren vanaf een bekend NP-compleet probleem.

### c) (2pt) Formuleer de stelling van Cook-Levin. Welke reductie wordt gebruikt in het bewijs van de stelling van Cook-Levin.

**Stelling van Cook-Levin**:
De stelling van Cook-Levin stelt dat het **SAT-probleem** (Satisfiability van propositionele formules in conjunctieve normaalvorm, CNF) **NP-compleet** is. Dit betekent:

1. $SAT \in NP$.
2. Elk probleem in $NP$ kan in polynomiale tijd worden gereduceerd naar $SAT$ ($SAT$ is $NP$-hard).

**Formulering**:

- $SAT = \{⟨\phi⟩ | \phi \text{ is een propositionele formule in CNF die satisfiable is}\}$.
- De stelling beweert dat $SAT$ in $NP$ zit en dat voor elke taal $L \in NP$, er een polynomiale reductie bestaat van L naar $SAT$.

**Reductie in het bewijs**:
Het bewijs van de stelling van Cook-Levin gebruikt een reductie van een willekeurige taal $L \in NP$ naar $SAT$.

## Vraag 2 Subsetsum (4pt)

### a) (2pt) Definieer formeel wat een polynomiale verifiër is, beschrijf het SUBSETSUM probleem én toon aan dat SUBSETSUM in NP zit door middel van een polynomiale verifiër.

**Definitie van een polynomiale verifiër**:
Een polynomiale verifiër voor een taal $L$ is een deterministische Turingmachine $V$ met twee inputs: een input $x$ en een certificaat $c$, zodanig dat:

- Er een polynomiale functie $p$ bestaat, zodat $V(x, c)$ in tijd $O(p(|x|))$ beslist of $x \in L$.
- Voor $x \in L$ bestaat er een certificaat c (met $|c| \leq p(|x|)$) zodat $V(x, c)$ aanvaardt.
- Voor $x \notin L$ bestaat er geen certificaat $c$ zodat $V(x, c)$ aanvaardt.

**Beschrijving van SUBSETSUM**:
Het SUBSETSUM-probleem wordt gedefinieerd als:

- $SUBSETSUM = \{⟨S, t⟩ | S = \{x_1, \dots , x_k\}\}$ is een multiset van natuurlijke getallen, en er bestaat een deel-multiset $T \subseteq S$ zodat $\sum\limits_{y \in T} y = t$.
- Intuïtief: Gegeven een verzameling getallen $S$ en een doelgetal $t$, bestaat er een subset van $S$ waarvan de som precies $t$ is?

**Bewijs dat SUBSETSUM in NP zit**:
We tonen aan dat SUBSETSUM in NP zit door een polynomiale verifiër te construeren.

- **Certificaat**: Het certificaat c is een deel-multiset T ⊆ S, voorgesteld als een lijst van elementen uit S (of een binaire vector die aangeeft welke elementen in T zitten).
- **Verifiër V**:
  1. Input: ⟨S, t⟩ en certificaat c (de deel-multiset T).
  2. Controleer of T een geldige deel-multiset van S is (elk element in T moet in S voorkomen, met juiste veelvoud).
  3. Bereken de som ∑\_{y∈T} y.
  4. Als de som gelijk is aan t, aanvaard; anders verwerp.
- **Tijdscomplexiteit**:
  - Controle van T als deel-multiset: O(k), waar k het aantal elementen in S is (vergelijk elementen in T met S).
  - Berekening van de som: O(k) voor het optellen van k getallen (aannemende dat elk getal in S polynomiaal is in de inputgrootte, d.w.z. log xᵢ = O(n)).
  - De grootte van de input is n = O(k log(max{xᵢ, t})), dus de verifiër werkt in polynomiale tijd O(n).
- **Correctheid**:
  - Als ⟨S, t⟩ ∈ SUBSETSUM, bestaat er een T ⊆ S met ∑\_{y∈T} y = t, en V(⟨S, t⟩, T) aanvaardt.
  - Als ⟨S, t⟩ ∉ SUBSETSUM, is er geen T ⊆ S met ∑\_{y∈T} y = t, en V(⟨S, t⟩, c) verwerpt voor elk certificaat c.
- **Conclusie**: Omdat er een polynomiale verifiër bestaat, zit SUBSETSUM in NP.

### b) (2pt) Beschrijf de reductie 3SAT ≤p SUBSETSUM in het algemeen én illustreer de reductie voor $\phi$ = (x₁ ∨ x₂ ∨ x₃) ∧ (¬x₂ ∨ x₃ ∨ x₄) ∧ (x₁ ∨ ¬x₂ ∨ ¬x₄). Toon aan in het algemeen dat een oplossing van het verkregen SUBSETSUM probleem overeenkomt met het satisfieerbaar zijn van het propositionele formule waarvan men vertrekt.

**Algemene beschrijving van de reductie 3SAT ≤p SUBSETSUM** (zie pagina 126-130):
De reductie zet een 3CNF-formule $\phi$ met ℓ variabelen x₁, ..., xₗ en k clauses c₁, ..., cₖ om in een SUBSETSUM-instantie ⟨S, t⟩, zodanig dat $\phi$ satisfiable is als en slechts als er een deel-multiset T ⊆ S bestaat met ∑\_{y∈T} y = t.

- **Constructie**:
  - **Multiset S**:
    - Voor elke variabele xᵢ (i = 1, ..., ℓ): Voeg getallen yᵢ en zᵢ toe om xᵢ = 1 (waar) respectievelijk xᵢ = 0 (onwaar) te vertegenwoordigen.
    - Voor elke clause cⱼ (j = 1, ..., k): Voeg getallen gⱼ en hⱼ toe om "slack" te creëren voor clauses.
  - **Getallen in S** (in decimale notatie, zie pagina 128):
    - yᵢ: Links een 1 op positie i, gevolgd door ℓ-i nullen; rechts een 1 op positie j als xᵢ in clause cⱼ zit, anders 0.
    - zᵢ: Links een 1 op positie i, gevolgd door ℓ-i nullen; rechts een 1 op positie j als ¬xᵢ in clause cⱼ zit, anders 0.
    - gⱼ, hⱼ: Een 1 op positie ℓ+j, gevolgd door k-j nullen (identiek voor gⱼ en hⱼ).
  - **Doel t**: Bestaat uit ℓ enen (voor variabelen) gevolgd door k drieën (voor clauses).
  - **Intuïtie**:
    - De eerste ℓ posities zorgen ervoor dat precies één van yᵢ of zᵢ wordt gekozen per variabele (voor een consistente toewijzing).
    - De laatste k posities zorgen ervoor dat elke clause minstens één waar literal heeft (som = 3), met gⱼ en hⱼ als "opvulling" om van 1 of 2 naar 3 te gaan.
- **Polynomiale tijd**: De constructie van S en t vereist O(ℓk) operaties (voor het vullen van de tabellen), wat polynomiaal is in de grootte van $\phi$.

**Illustratie voor $\phi$ = (x₁ ∨ x₂ ∨ x₃) ∧ (¬x₂ ∨ x₃ ∨ x₄) ∧ (x₁ ∨ ¬x₂ ∨ ¬x₄)**:

- **Variabelen**: x₁, x₂, x₃, x₄ (ℓ = 4).
- **Clauses**:
  - c₁ = (x₁ ∨ x₂ ∨ x₃)
  - c₂ = (¬x₂ ∨ x₃ ∨ x₄)
  - c₃ = (x₁ ∨ ¬x₂ ∨ ¬x₄)
    (k = 3).
- **Constructie van S**:
  - **Tabel** (decimale notatie, zoals op pagina 127-128):
    - Posities: 1, 2, 3, 4 (voor variabelen), 5, 6, 7 (voor clauses c₁, c₂, c₃).
    - y₁: Links 1000 (1 op positie 1); rechts 101 (1 voor c₁, c₃ waar x₁ voorkomt).
      - y₁ = 1000101
    - z₁: Links 1000; rechts 000 (¬x₁ komt niet voor).
      - z₁ = 1000000
    - y₂: Links 0100; rechts 100 (1 voor c₁ waar x₂ voorkomt).
      - y₂ = 0100100
    - z₂: Links 0100; rechts 011 (1 voor c₂, c₃ waar ¬x₂ voorkomt).
      - z₂ = 0100011
    - y₃: Links 0010; rechts 110 (1 voor c₁, c₂ waar x₃ voorkomt).
      - y₃ = 0010110
    - z₃: Links 0010; rechts 000 (¬x₃ komt niet voor).
      - z₃ = 0010000
    - y₄: Links 0001; rechts 010 (1 voor c₂ waar x₄ voorkomt).
      - y₄ = 0001010
    - z₄: Links 0001; rechts 001 (1 voor c₃ waar ¬x₄ voorkomt).
      - z₄ = 0001001
    - g₁, h₁: 100 (1 op positie 5).
      - g₁ = h₁ = 0000100
    - g₂, h₂: 010 (1 op positie 6).
      - g₂ = h₂ = 0000010
    - g₃, h₃: 001 (1 op positie 7).
      - g₃ = h₃ = 0000001
  - **Doel t**: ℓ enen (1111) gevolgd door k drieën (333).
    - t = 1111333
- **SUBSETSUM-instantie**: S = {y₁, z₁, y₂, z₂, y₃, z₃, y₄, z₄, g₁, h₁, g₂, h₂, g₃, h₃}, t = 1111333.

**Algemene correctheid van de reductie**:
We tonen aan dat $\phi$ satisfiable is ⇔ ⟨S, t⟩ ∈ SUBSETSUM.

- **Voorwaartse richting ($\phi$ satisfiable ⇒ ⟨S, t⟩ ∈ SUBSETSUM)**:
  - Stel dat $\phi$ satisfiable is, met een toewijzing ν: {x₁, ..., xₗ} → {0, 1} die $\phi$ waar maakt.
  - Construeer T ⊆ S:
    - Voor elke variabele xᵢ:
      - Als ν(xᵢ) = 1, voeg yᵢ toe aan T.
      - Als ν(xᵢ) = 0, voeg zᵢ toe aan T.
    - Dit zorgt ervoor dat de som in de eerste ℓ posities precies 111...1 (ℓ enen) is, omdat precies één van yᵢ of zᵢ per variabele wordt gekozen (elk draagt 1 bij op positie i).
    - Voor de laatste k posities (clauses):
      - Omdat ν $\phi$ waar maakt, heeft elke clause cⱼ minstens één waar literal.
      - Als xᵢ in cⱼ zit en ν(xᵢ) = 1, draagt yᵢ een 1 bij aan positie ℓ+j.
      - Als ¬xᵢ in cⱼ zit en ν(xᵢ) = 0, draagt zᵢ een 1 bij aan positie ℓ+j.
      - Elke clause cⱼ krijgt dus 1, 2, of 3 enen van de yᵢ’s en zᵢ’s (afhankelijk van het aantal waar literals).
      - Voeg nul, één, of twee van {gⱼ, hⱼ} toe aan T om de som op positie ℓ+j precies 3 te maken (gⱼ en hⱼ dragen elk 1 bij).
    - De som van T is dan t = 111...1333...3.
  - Dus, ⟨S, t⟩ ∈ SUBSETSUM.
- **Omgekeerde richting (⟨S, t⟩ ∈ SUBSETSUM ⇒ $\phi$ satisfiable)**:
  - Stel dat er een T ⊆ S bestaat met ∑\_{x∈T} x = t.
  - **Eerste ℓ posities**:
    - De som is 111...1, wat betekent dat precies één van yᵢ of zᵢ per variabele in T zit (anders zou de som >1 of <1 zijn op positie i, omdat gⱼ en hⱼ geen bijdrage leveren aan deze posities).
    - Definieer ν(xᵢ) = 1 als yᵢ ∈ T, anders ν(xᵢ) = 0 (als zᵢ ∈ T).
  - **Laatste k posities**:
    - De som is 333...3, wat betekent dat elke positie ℓ+j precies 3 draagt.
    - Omdat gⱼ en hⱼ elk 1 bijdragen, en er hoogstens twee (gⱼ, hⱼ) zijn, moet minstens één yᵢ of zᵢ een 1 bijdragen aan positie ℓ+j.
    - Dit betekent dat voor elke clause cⱼ minstens één literal waar is onder ν:
      - Als yᵢ ∈ T en xᵢ in cⱼ, dan is ν(xᵢ) = 1 en is xᵢ waar.
      - Als zᵢ ∈ T en ¬xᵢ in cⱼ, dan is ν(xᵢ) = 0 en is ¬xᵢ waar.
    - Dus, elke clause cⱼ is waar onder ν.
  - Dus, ν maakt $\phi$ satisfiable.
  - **Conclusie**: De reductie is correct, want $\phi$ is satisfiable ⇔ ⟨S, t⟩ ∈ SUBSETSUM.

**Voorbeeldverificatie** (optioneel, ter illustratie):
Voor $\phi$ = (x₁ ∨ x₂ ∨ x₃) ∧ (¬x₂ ∨ x₃ ∨ x₄) ∧ (x₁ ∨ ¬x₂ ∨ ¬x₄), een satisfiable toewijzing is ν(x₁) = 1, ν(x₂) = 0, ν(x₃) = 1, ν(x₄) = 0:

- T = {y₁, z₂, y₃, z₄, g₂, h₂, g₃, h₃}:
  - y₁ = 1000101, z₂ = 0100011, y₃ = 0010110, z₄ = 0001001.
  - g₂ = h₂ = 0000010, g₃ = h₃ = 0000001.
  - Som: 1111333 (controleer per positie).
- Dit komt overeen met een oplossing voor SUBSETSUM, en ν maakt $\phi$ waar.

Vraag 3 PSPACE en NPSPACE (4pt)

a) (1pt) Formuleer de stelling van Savitch en toon aan wat hieruit volgt door de klassen PSPACE en NPSPACE. Laat zien dat je de definities van deze complexiteitsklassen kent.

b) (1pt) IS $NP \subseteq PSPACE$ of $PSPACE \subseteq NP$? Wat kan je verder zeggen over de tijdscomplexiteit van problemen in PSPACE? Leg uit.

c) (2pt) In het bewijs vn de steelling van Savitch laten we de procedure ISBEREIKBAAR, los op de configuratie graaf van de uitvoering van een Turingmachine M op een input woord w. Antwoord de volgende vragen:

- Vul de volgende pseudo-code verder aan:

```
ISBEREIKBAAR(c1, C2, t)
Als t = 1, check [vul aan]
Als t > 1 dan [vul aan]
	Voer ISBEREIKBAAR([vul aan])
	Voer ISBEREIKBAAR([vul aan])
Als beiden aanvaarden, aanvaard. Als nog niet aanvaard, verwerp.
```

- Hoe wordt uiteindelijk bereikbaar gebruikt in het bewijs van de stelling van Savitch? Leg uit dat het hergebruik van plaats cruciaal is.

Vraag 4 NLOGSPACE (4pt)

a) (2pt) Toon aan dat $\overline{2SAT}$ in NLOGSPACE zit. Beschrijf het algoritme in voldoende detail en argumenteer waarom het een NLOGSPACE algoritme is. Uit je antwoorden moet duidelijk zijn wat voor Turingmachines gebruikt worden. Ook nog, wat kan je zeggen over de plaatscomplexiteit van $2SAT$?

b) (2pt) Formuleer de stelling van Immerman-Szelepcsényi. Leg uit hoe, in het bewijs van deze stelling, gegeven <G,s,t,c>, met G een gerichte graaf, s en t begin een eind knoop en c het aantal knopen bereikbaar uit s, beslist wordt dat er geen pad is van s naar t.
