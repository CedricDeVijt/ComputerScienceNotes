### Vraag 1: PTIME en NP (60pt)

#### (1) (25pt) Leg uit wat precies de vraag "PTIME = NP?" betekent. Laat zien dat je de onderliggende definities kent, inclusief welke Turingmachines worden gebruikt.

**Betekenis van "PTIME = NP?"**:
De vraag "PTIME = NP?" vraagt of de complexiteitsklasse **PTIME** (ook wel P genoemd) gelijk is aan de complexiteitsklasse **NP**. Dit is een fundamentele open vraag in de complexiteitstheorie die vraagt of elk probleem waarvan een oplossing in polynomiale tijd kan worden geverifieerd (NP) ook in polynomiale tijd kan worden opgelost (PTIME). Hieronder leg ik de definities en concepten uit, inclusief de rol van Turingmachines.

**Definitie van PTIME**:

- **PTIME** (Polynomiale Tijd) is de verzameling van talen $L \subseteq \Sigma^\*$ die beslist kunnen worden door een **deterministische Turingmachine (DTM)** in polynomiale tijd.
- Formeel: Een taal $L \in \text{PTIME}$ als er een DTM $M$ bestaat zodanig dat voor elke input $x \in \Sigma^\*$:
  - $M$ halt (aanvaardt of verwerpt) in tijd $O(p(|x|))$, waarbij $p$ een polynomiale functie is en $|x|$ de lengte van $x$.
  - Als $x \in L$, aanvaardt $M$; als $x \notin L$, verwerpt $M$.
- **Turingmachine**: Een DTM heeft één berekeningspad per input. De tijdscomplexiteit is het aantal stappen dat $M$ uitvoert op $x$, en voor PTIME moet dit polynomiaal zijn (bijv. $O(n^k)$ voor een constante $k$).
- Voorbeeld: De taal $\{ \langle G, s, t \rangle \mid G \text{ heeft een pad van } s \text{ naar } t \}$ is in PTIME, want een breedte-eerst-zoekalgoritme beslist dit in $O(|V| + |E|)$.

**Definitie van NP**:

- **NP** (Niet-deterministische Polynomiale Tijd) is de verzameling van talen $L \subseteq \Sigma^\*$ waarvoor een oplossing in polynomiale tijd kan worden geverifieerd door een **deterministische Turingmachine** of die beslist kunnen worden door een **niet-deterministische Turingmachine (NDTM)** in polynomiale tijd.
- **Verifiër-definitie**:
  - Een taal $L \in \text{NP}$ als er een DTM-verifiër $V$ en een polynomiale functie $p$ bestaan, zodanig dat voor elke $x \in \Sigma^\*$:
    - Als $x \in L$, er een certificaat $c$ bestaat met $|c| \leq p(|x|)$, zodat $V(x, c)$ aanvaardt in tijd $O(p(|x|))$.
    - Als $x \notin L$, geen certificaat $c$ bestaat zodat $V(x, c)$ aanvaardt.
  - Intuïtief: Een certificaat is een "bewijs" dat $x \in L$, en de verifiër controleert dit efficiënt.
- **NDTM-definitie**:
  - Een taal $L \in \text{NP}$ als er een NDTM $M$ bestaat die $L$ beslist in polynomiale tijd. Een NDTM heeft meerdere berekeningspaden door niet-deterministische keuzes, en $M$ aanvaardt als minstens één pad aanvaardt.
  - De tijdscomplexiteit van een NDTM is de maximale lengte van een berekeningspad (over alle paden), en voor NP moet dit $O(p(n))$ zijn.
- **Turingmachines**:
  - **DTM-verifiër**: Gebruikt voor verificatie, met twee inputs ($x, c$) en één berekeningspad.
  - **NDTM**: Simuleert het "gokken" van een certificaat en verifieert het in één pad. De twee definities zijn equivalent, omdat een NDTM die in polynomiale tijd beslist overeenkomt met een DTM-verifiër.
- Voorbeeld: De taal $\text{SAT} = \{ \langle \phi \rangle \mid \phi \text{ is een satisfiable CNF-formule} \}$ is in NP, want een waarheidstoewijzing $\nu$ (certificaat) kan in polynomiale tijd worden geverifieerd.

**Relatie tussen PTIME en NP**:

- **PTIME $\subseteq$ NP**: Elk probleem in PTIME is in NP, want als een DTM $M$ een taal $L$ in polynomiale tijd beslist, kan een verifiër $V(x, c)$ de berekening van $M$ op $x$ simuleren zonder certificaat ($c$ wordt genegeerd), wat in polynomiale tijd werkt.
- **De vraag "PTIME = NP?"**:
  - Als $\text{PTIME} = \text{NP}$, dan kan elk probleem dat in polynomiale tijd verifieerbaar is (NP) ook in polynomiale tijd worden opgelost. Dit zou betekenen dat problemen zoals SAT, HAMPATH, en 3SAT efficiënt oplosbaar zijn.
  - Als $\text{PTIME} \neq \text{NP}$, bestaan er problemen in NP (zoals mogelijk NP-complete problemen) die niet in polynomiale tijd kunnen worden opgelost.
- **Turingmachines in de context**:
  - Voor PTIME: Alleen DTM’s worden gebruikt, omdat de oplossing deterministisch moet zijn.
  - Voor NP: DTM’s worden gebruikt als verifiërs, en NDTM’s bieden een alternatieve karakterisering. De kracht van NDTM’s ligt in hun vermogen om meerdere paden te verkennen, wat overeenkomt met het gokken van een certificaat.

**Implicaties**:

- De vraag is cruciaal voor cryptografie, optimalisatie, en algoritmiek. Als $\text{P} = \text{NP}$, zouden veel problemen (bijv. codebreken) efficiënt oplosbaar zijn, wat verstrekkende gevolgen heeft.
- De meeste experts geloven dat $\text{P} \neq \text{NP}$, maar er is geen bewijs.

**Samenvatting van Turingmachines**:

- **DTM**: Enig berekeningspad, gebruikt voor PTIME en als verifiër in NP.
- **NDTM**: Meerdere paden, gebruikt om NP te karakteriseren via niet-deterministische beslissing in polynomiale tijd.

#### (2) (10pt) In het bewijs van de Stelling van Cook-Levin wordt een formule $\phi = \phi*{\text{cell}} \wedge \phi*{\text{start}} \wedge \phi*{\text{move}} \wedge \phi*{\text{accept}}$ geconstrueerd. Wat is de input van het algoritme dat $\phi$ genereert? Aan welke eigenschap(pen) moet $\phi$ voldoen voor een reductie?

**Input van het algoritme dat $\phi$ genereert**:

- Het algoritme dat $\phi$ construeert is onderdeel van een reductie van een willekeurige taal $L \in \text{NP}$ naar SAT. De input van het algoritme is:
  - Een inputstring $x \in \Sigma^\*$ voor de taal $L$.
  - Een beschrijving van een polynomiale verifiër $V$ voor $L$, een deterministische Turingmachine die in tijd $p(|x|)$ (voor een polynoom $p$) beslist of $x \in L$ gegeven een certificaat $c$.
- Formeel: De input is $\langle x, V \rangle$, waarbij $V$ vast is voor $L$, en $x$ de specifieke instantie is. In de praktijk wordt vaak alleen $x$ als input beschouwd, omdat $V$ impliciet deel is van de reductie voor $L$.
- De verifiër $V$ heeft een transitiefunctie $\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$, een tape-alfabet $\Gamma$, toestanden $Q$, en een accepterende toestand $q\_{\text{accept}}$.

**Eigenschap(pen) waaraan $\phi$ moet voldoen voor een reductie**:
Voor een geldige polynomiale reductie van $L$ naar SAT ($L \leq_p \text{SAT}$), moet de geconstrueerde CNF-formule $\phi$ de volgende eigenschappen hebben:

1. **Correctheid van de reductie**:
   - $x \in L \iff \phi \text{ is satisfiable}$.
   - Dit betekent dat $\phi$ satisfiable is (er bestaat een waarheidstoewijzing die alle clauses waar maakt) als en slechts als er een certificaat $c$ bestaat zodanig dat $V(x, c)$ aanvaardt, wat overeenkomt met $x \in L$.
2. **Polynomiale tijd constructie**:
   - Het algoritme dat $\phi$ genereert uit $x$ (en $V$) moet in polynomiale tijd werken, d.w.z. $O(q(|x|))$ voor een polynoom $q$.
   - De grootte van $\phi$ (aantal clauses en literals) moet polynomiaal zijn in $|x|$, omdat SAT een probleem over CNF-formules is, en de inputgrootte van $\phi$ moet overeenkomen met de complexiteit van de reductie.
3. **CNF-vorm**:
   - $\phi$ moet een propositionele formule in conjunctieve normaalvorm (CNF) zijn, omdat SAT gedefinieerd is over CNF-formules.
   - Dit betekent dat $\phi$ een conjunctie is van clauses, waarbij elke clause een disjunctie van literals is (variabelen of hun negaties).

**Uitleg**:

- De formule $\phi = \phi*{\text{cell}} \wedge \phi*{\text{start}} \wedge \phi*{\text{move}} \wedge \phi*{\text{accept}}$ simuleert de berekening van $V$ op input $\langle x, c \rangle$:
  - $\phi\_{\text{cell}}$: Zorgt voor consistente configuraties (elke cel heeft precies één symbool of toestand).
  - $\phi\_{\text{start}}$: Stelt de initiële configuratie in (starttoestand, input $x$, certificaat $c$).
  - $\phi\_{\text{move}}$: Garandeert geldige overgangen tussen configuraties volgens $\delta$.
  - $\phi\_{\text{accept}}$: Vereist dat een accepterende toestand wordt bereikt.
- Een satisfiable $\phi$ komt overeen met een geldige, accepterende berekening van $V$, wat betekent dat $x \in L$. De reductie is polynomiaal omdat $\phi$ wordt geconstrueerd in tijd $O(p(|x|)^2)$, en de grootte van $\phi$ is polynomiaal.

#### (3) (15pt) Leg uit hoe $\phi\_{\text{move}}$ gedefinieerd wordt en waarom dit werkt. Geef een informele uitleg.

**Definitie van $\phi\_{\text{move}}$**:

- **Doel**: $\phi\_{\text{move}}$ zorgt ervoor dat de overgangen tussen configuraties van de verifiër $V$ in de berekeningstabel correct zijn volgens de transitiefunctie $\delta$. Het garandeert dat de configuratie op tijd $t+1$ (rij $t+2$) volgt uit de configuratie op tijd $t$ (rij $t+1$) volgens de regels van $V$.
- **Constructie**:
  - De berekening van $V$ wordt voorgesteld als een tabel van $p(n) \times p(n)$ cellen, waarbij rij $t+1$ (1 ≤ $t \leq p(n)$) de configuratie op tijd $t$ voorstelt, en kolom $j$ de tape-positie $j-1$.
  - Variabelen:
    - $x\_{t,j,a}$: Waar als cel $(t, j)$ symbool $a \in \Gamma$ bevat.
    - $q\_{t,j,q}$: Waar als cel $(t, j)$ toestand $q \in Q$ bevat (de kop is op positie $j-1$).
  - $\phi\_{\text{move}}$ is een conjunctie van clauses die lokale consistentie afdwingen voor elke tijdstap $t$ en tape-positie $j$. Het controleert "windows" van drie tape-posities ($j-1, j, j+1$) tussen tijd $t$ en $t+1$.
  - Voor een window rond positie $j$ op tijd $t$:
    - Als de kop niet in $j-1, j, j+1$ is, blijven de symbolen op $(t+1, j-1), (t+1, j), (t+1, j+1)$ ongewijzigd.
    - Als de kop op positie $j$ is in toestand $q$, en symbool $a$ leest ($q*{t,j,q} \wedge x*{t,j,a}$), en $\delta(q, a) = (q', b, d)$, dan:
      - Schrijf $b$ op positie $j$: $x\_{t+1,j,b}$.
      - Verplaats de kop:
        - Als $d = R$, nieuwe toestand op $(t+1, j+1)$: $q\_{t+1,j+1,q'}$.
        - Als $d = L$, nieuwe toestand op $(t+1, j-1)$: $q\_{t+1,j-1,q'}$.
      - Aangrenzende posities ($j-1, j+1$) behouden hun symbool als de kop daar niet naartoe beweegt.
  - Dit wordt uitgedrukt als CNF-clauses, bijvoorbeeld:
    - Voor een overgang $\delta(q, a) = (q', b, R)$, voeg clauses toe zoals:
      $$
      (q*{t,j,q} \wedge x*{t,j,a} \wedge x*{t,j-1,c} \wedge x*{t,j+1,d}) \to (x*{t+1,j,b} \wedge q*{t+1,j+1,q'} \wedge x*{t+1,j-1,c} \wedge x*{t+1,j+1,d}).
     $$
    - Deze implicaties worden omgezet naar CNF (bijv. door negatie en De Morgan).
  - Clauses worden gegenereerd voor alle $t, j$, alle mogelijke toestanden, symbolen, en overgangen.

**Waarom werkt $\phi\_{\text{move}}$** (informele uitleg):

- **Wat doet $\phi\_{\text{move}}$**:
  - $\phi*{\text{move}}$ is als een regelboek dat ervoor zorgt dat elke stap van de Turingmachine $V$ klopt. Stel je voor dat je een film maakt van hoe $V$ werkt: elke frame (rij in de tabel) toont de tape, de toestand, en waar de kop is. $\phi*{\text{move}}$ controleert of frame $t+1$ logisch volgt uit frame $t$.
  - Het kijkt naar kleine stukjes van de tape (de "windows") rond de kop, omdat alleen de positie van de kop en de aangrenzende posities veranderen per stap. Als de machine bijvoorbeeld in toestand $q$ symbool $a$ leest en moet overschrijven met $b$ en naar rechts bewegen, zorgt $\phi\_{\text{move}}$ ervoor dat de volgende rij in de tabel dat weerspiegelt: $b$ op de huidige positie, de kop één positie naar rechts in de nieuwe toestand, en de rest van de tape onveranderd.
- **Waarom is het correct**:
  - Als $\phi$ satisfiable is, betekent dit dat er een reeks waarheidswaarden voor de variabelen bestaat die alle clauses in $\phi\_{\text{move}}$ waar maakt. Dit komt neer op een geldige berekening van $V$, waarbij elke stap consistent is met de regels van $V$.
  - $\phi*{\text{move}}$ dwingt af dat de Turingmachine zich gedraagt zoals hij moet: de kop beweegt correct, symbolen worden correct overschreven, en de toestand verandert volgens $\delta$. Zonder $\phi*{\text{move}}$ zouden we ongeldige berekeningen kunnen krijgen (bijv. de kop springt willekeurig of symbolen veranderen zonder reden).
- **Waarom is het efficiënt**:
  - De clauses in $\phi\_{\text{move}}$ zijn lokaal: ze kijken alleen naar een klein stukje van de tape (drie posities). Dit maakt de constructie overzichtelijk en polynomiaal in grootte, omdat we alleen clauses nodig hebben voor elke tijdstap en positie.
- **Link met de reductie**:
  - Samen met $\phi*{\text{cell}}, \phi*{\text{start}}, \phi*{\text{accept}}$ zorgt $\phi*{\text{move}}$ ervoor dat $\phi$ alleen satisfiable is als $V$ een accepterende berekening heeft, wat betekent dat $x \in L$. $\phi\_{\text{move}}$ is cruciaal omdat het de dynamiek van de berekening vastlegt.

#### (4) (10pt) Wat zou een gevolg zijn als 3SAT ∈ PTIME? Geef een formele argumentatie.

**Gevolg**:
Als 3SAT $\in \text{PTIME}$, zou dit betekenen dat $\text{PTIME} = \text{NP}$, omdat 3SAT een NP-compleet probleem is. Dit zou een fundamentele doorbraak zijn in de complexiteitstheorie met verstrekkende implicaties.

**Formele argumentatie**:

- **3SAT is NP-compleet**:
  - 3SAT = $\{ \langle \phi \rangle \mid \phi \text{ is een 3CNF-formule die satisfiable is} \}$, waarbij elke clause precies drie literals bevat.
  - 3SAT $\in \text{NP}$: Een waarheidstoewijzing $\nu$ kan in polynomiale tijd worden geverifieerd door elke clause te controleren.
  - 3SAT is **NP-hard**: Elke taal $L \in \text{NP}$ is polynomiaal reduceerbaar naar 3SAT ($L \leq_p \text{3SAT}$), zoals bewezen via reducties (bijv. SAT $\leq_p \text{3SAT}$).
- **Veronderstelling: 3SAT $\in \text{PTIME}$**:
  - Als 3SAT $\in \text{PTIME}$, bestaat er een deterministische Turingmachine $M$ die in polynomiale tijd beslist of een 3CNF-formule $\phi$ satisfiable is, d.w.z. in tijd $O(p(|\phi|))$ voor een polynoom $p$.
- **Gevolg voor NP**:
  - Omdat 3SAT NP-compleet is, betekent $L \leq_p \text{3SAT}$ voor elke $L \in \text{NP}$ dat we $L$ kunnen oplossen door:
    1. Een instantie $x$ van $L$ om te zetten in een 3SAT-instantie $\phi = f(x)$ via een polynomiale reductie $f$, wat tijd $O(q(|x|))$ kost voor een polynoom $q$.
    2. Het 3SAT-algoritme $M$ uit te voeren op $\phi$, wat tijd $O(p(|\phi|))$ kost. Omdat $|\phi|$ polynomiaal is in $|x|$ (door de reductie), is $p(|\phi|)$ polynomiaal in $|x|$.
  - De totale tijd is $O(q(|x|)) + O(p(|\phi|))$, wat polynomiaal is in $|x|$.
  - Dus, elke taal $L \in \text{NP}$ kan in polynomiale tijd worden beslist, wat betekent dat $\text{NP} \subseteq \text{PTIME}$.
- **PTIME $\subseteq$ NP**:
  - Elk probleem in PTIME is in NP, omdat een DTM die in polynomiale tijd beslist direct een verifiër oplevert (geen certificaat nodig).
- **Conclusie**:
  - Als $\text{NP} \subseteq \text{PTIME}$ en $\text{PTIME} \subseteq \text{NP}$, dan $\text{PTIME} = \text{NP}$.
- **Implicaties**:
  - Als $\text{P} = \text{NP}$, zouden alle NP-complete problemen (zoals SAT, HAMPATH, SUBSETSUM) en veel praktische problemen (bijv. cryptografische systemen zoals RSA) in polynomiale tijd oplosbaar zijn.
  - Dit zou de grondslagen van cryptografie ondermijnen, omdat veel beveiligingssystemen vertrouwen op de veronderstelling dat $\text{P} \neq \text{NP}$.
  - Het zou ook betekenen dat problemen zoals optimalisatie, planning, en verificatie efficiënt oplosbaar zijn, wat een revolutie in technologie en wetenschap zou veroorzaken.

**Samenvattend**: Als 3SAT $\in \text{PTIME}$, volgt $\text{P} = \text{NP}$, wat een paradigmaverschuiving in computationele complexiteit zou betekenen.

### Vraag 2: HAMPATH (60pt)

#### (1) (15pt) Toon aan dat HAMPATH in NP zit door middel van een polynomiale verifiër.

**Definitie van HAMPATH**:
$$
\text{HAMPATH} = \{ \langle G, s, t \rangle \mid G \text{ is een gerichte graaf met een Hamiltoniaans pad van vertex } s \text{ naar } t \}.
$$
Een Hamiltoniaans pad is een pad in $G = (V, E)$ dat elke vertex in $V$ precies één keer bezoekt, beginnend bij $s$ en eindigend bij $t$.

**Bewijs dat HAMPATH ∈ NP**:
We tonen aan dat HAMPATH in NP zit door een polynomiale verifiër te construeren.

- **Certificaat**: Het certificaat $c$ is een volgorde van vertices $P = [v_1, v_2, \ldots, v_n]$, waarbij $v_1 = s$, $v_n = t$, en $n = |V|$. Dit vertegenwoordigt een mogelijk Hamiltoniaans pad.
- **Verifiër V**:
  1. Input: $\langle G, s, t \rangle$ en certificaat $c$ (volgorde $P$).
  2. Controleer of $P$ een geldig Hamiltoniaans pad is:
     - Controleer of $v_1 = s$ en $v_n = t$.
     - Controleer of $P$ alle vertices in $V$ precies één keer bevat (gebruik een hashset om duplicaten en volledigheid te controleren).
     - Voor $i = 1$ tot $n-1$, controleer of $(v*i, v*{i+1}) \in E$.
  3. Als alle controles slagen, aanvaard; anders verwerp.
- **Tijdscomplexiteit**:
  - **Inputgrootte**: $n = |V|$, $m = |E|$. De grootte van $\langle G, s, t \rangle$ is $O(n^2)$ (adjacency matrix) of $O(n + m)$ (adjacency lijst).
  - **Stap 2**:
    - Controleer $v_1 = s$, $v_n = t$: $O(1)$.
    - Controleer uniciteit en volledigheid van vertices: $O(n)$ (met een hashset).
    - Controleer bogen: Voor $n-1$ bogen, kost elke controle $O(1)$ (matrix) of $O(n)$ (lijst). Totaal: $O(n)$ (matrix) of $O(n^2)$ (lijst).
  - **Totaal**: $O(n)$ (matrix) of $O(n^2)$ (lijst), beide polynomiaal.
- **Correctheid**:
  - Als $\langle G, s, t \rangle \in \text{HAMPATH}$, bestaat er een Hamiltoniaans pad $P$. De verifiër aanvaardt $V(\langle G, s, t \rangle, P)$.
  - Als $\langle G, s, t \rangle \notin \text{HAMPATH}$, is geen volgorde $P$ een Hamiltoniaans pad (mislukt op uniciteit, volledigheid, of bogen), en de verifiër verwerpt.
- **Conclusie**: HAMPATH $\in \text{NP}$.

#### (2) (5pt) Wat betekent 3SAT ≤p HAMPATH voor HAMPATH? Leg uit.

**Betekenis van 3SAT ≤p HAMPATH**:

- De notatie $\text{3SAT} \leq_p \text{HAMPATH}$ betekent dat er een polynomiale reductie bestaat van het 3SAT-probleem naar het HAMPATH-probleem. Formeel:
  - Er is een functie $f$, berekenbaar in polynomiale tijd, die een 3SAT-instantie $\phi$ omzet in een HAMPATH-instantie $\langle G, s, t \rangle$, zodanig dat:
    $$
    \phi \text{ is satisfiable} \iff \langle G, s, t \rangle \in \text{HAMPATH}.
   $$
- **Implicaties voor HAMPATH**:
  - **HAMPATH is NP-hard**: 3SAT is NP-compleet, wat betekent dat elke taal $L \in \text{NP}$ polynomiaal reduceerbaar is naar 3SAT. Omdat $\text{3SAT} \leq_p \text{HAMPATH}$, is elke $L \in \text{NP}$ ook reduceerbaar naar HAMPATH (via transitiviteit: $L \leq_p \text{3SAT} \leq_p \text{HAMPATH}$). Dus, HAMPATH is NP-hard.
  - **HAMPATH is NP-compleet**: Omdat HAMPATH $\in \text{NP}$ (zoals bewezen in (1)) en NP-hard is, is HAMPATH NP-compleet.
  - **Gevolg**: HAMPATH is minstens zo moeilijk als 3SAT en alle andere NP-problemen. Als HAMPATH in polynomiale tijd oplosbaar is, zou 3SAT (en elk NP-probleem) dat ook zijn, wat $\text{P} = \text{NP}$ impliceert.
- **Praktisch**: De reductie toont aan dat HAMPATH een "universeel" probleem is binnen NP, geschikt om de moeilijkheid van andere NP-problemen mee te bewijzen.

#### (3) (10pt) Gegeven Figuur 1, wat is $n$ (aantal variabelen) en $m$ (aantal clauses)? Vervolledig Figuur 1 zodat de reductie duidelijk is.

**Aannames over Figuur 1**:

- Figuur 1 toont een deel van de graafconstructie voor de reductie $\text{3SAT} \leq_p \text{HAMPATH}$, maar de specifieke formule $\phi$ is niet gegeven. We nemen aan dat Figuur 1 een fragment toont van de graaf voor een 3SAT-formule $\phi = C_1 \wedge \ldots \wedge C_m$ over variabelen $X = \{x_1, \ldots, x_n\}$.
- De standaardconstructie (zie cursusmateriaal, bijv. Sipser) bouwt een graaf met "diamantstructuren" voor variabelen en vertices voor clauses. We veronderstellen dat Figuur 1 een deel van een diamantstructuur voor een variabele $x_i$ en/of een clause-vertex toont.

**Bepalen van $n$ en $m$**:

- Zonder een specifieke figuur is het moeilijk om exacte waarden voor $n$ en $m$ te bepalen. We maken een redelijke aanname gebaseerd op de standaardconstructie:
  - Een diamantstructuur voor variabele $x_i$ heeft typisch $2m + 2$ vertices (voor $m$ clauses, met een "waar"- en "onwaar"-pad). Als Figuur 1 een diamantstructuur toont met $2m + 2$ vertices, kunnen we $m$ afleiden uit het aantal vertices.
  - Als Figuur 1 clause-vertices $e_j$ toont, is $m$ het aantal zichtbare clause-vertices.
  - Voor $n$, als Figuur 1 meerdere diamantstructuren toont, is $n$ het aantal structuren.
- **Hypothetisch antwoord**: Stel dat Figuur 1 één diamantstructuur toont met 8 vertices (bijv. $a*{i,1}, b*{i,1}, \ldots, b*{i,3}, a*{i,4}$) en 3 clause-vertices $e_1, e_2, e_3$. Dan:
  - $m = 3$ (aantal clauses, afgeleid uit clause-vertices of de grootte van de diamant: $2m + 2 = 8 \implies m = 3$).
  - $n = 1$ (als alleen één variabele-structuur wordt getoond; anders meer als meerdere structuren zichtbaar zijn).
- **Algemene aanpak**: Zonder figuur moeten $n$ en $m$ worden afgeleid uit de context van de graaf. In de volledige reductie:
  - $n$: Aantal variabele-structuren (diamanten).
  - $m$: Aantal clause-vertices $e_j$ of afgeleid uit de grootte van een diamantstructuur.

**Vervollediging van Figuur 1**:
De reductie $\text{3SAT} \leq_p \text{HAMPATH}$ construeert een gerichte graaf $G = (V, E)$ met startvertex $s$, eindvertex $t$, en een Hamiltoniaans pad van $s$ naar $t$ als en slechts als $\phi$ satisfiable is. Hier is de volledige constructie, inclusief hoe Figuur 1 wordt uitgebreid:

- **Vertices**:
  - Twee speciale vertices: $s$ (start) en $t$ (einde).
  - Voor elke variabele $x_i$ (i = 1, ..., $n$): Een diamantstructuur met:
    - "Waar"-pad: $a*{i,1}, b*{i,1}, b*{i,2}, \ldots, b*{i,m}, a\_{i,m+1}$.
    - "Onwaar"-pad: $c*{i,1}, d*{i,1}, d*{i,2}, \ldots, d*{i,m}, c\_{i,m+1}$.
    - Verbindingen: $c*{i,1} \to a*{i,1}$, $a*{i,m+1} \to c*{i,m+1}$.
  - Voor elke clause $c_j$ (j = 1, ..., $m$): Een vertex $e_j$.
- **Bogen**:
  - **Binnen variabele-structuren**:
    - Waar-pad: $(a*{i,1}, b*{i,1}), (b*{i,1}, b*{i,2}), \ldots, (b*{i,m}, a*{i,m+1})$.
    - Onwaar-pad: $(c*{i,1}, d*{i,1}), (d*{i,1}, d*{i,2}), \ldots, (d*{i,m}, c*{i,m+1})$.
    - Verbindingen: $(c*{i,1}, a*{i,1}), (a*{i,m+1}, c*{i,m+1})$.
  - **Tussen variabelen**:
    - Voor $i = 1, \ldots, n-1$: $(c*{i,m+1}, a*{i+1,1})$.
  - **Van en naar $s, t$**:
    - $(s, a\_{1,1})$.
    - $(c\_{n,m+1}, t)$.
  - **Clause-verbindingen**:
    - Voor clause $c*j = (l*{j,1} \vee l*{j,2} \vee l*{j,3})$:
      - Als $l*{j,k} = x_i$, voeg bogen $(b*{i,j-1}, e*j), (e_j, b*{i,j})$ toe (of $(a*{i,1}, e_j), (e_j, b*{i,1})$ als $j = 1$).
      - Als $l*{j,k} = \neg x_i$, voeg bogen $(d*{i,j-1}, e*j), (e_j, d*{i,j})$ toe (of $(c*{i,1}, e_j), (e_j, d*{i,1})$ als $j = 1$).
- **Integratie van Figuur 1**:
  - Als Figuur 1 een diamantstructuur voor $x*i$ toont, voeg de overige $n-1$ diamantstructuren toe, verbind ze via $c*{i,m+1} \to a\_{i+1,1}$, en voeg clause-vertices $e_j$ met hun bogen.
  - Als Figuur 1 clause-vertices toont, voeg de variabele-structuren en verbindingen naar $s, t$ toe.
  - De graaf heeft $O(nm)$ vertices ($2m+2$ per variabele, $m$ clauses, plus $s, t$) en $O(nm)$ bogen, polynomiaal in $n+m$.

#### (4) (15pt) Toon aan dat de vervolledigde constructie aantoont dat 3SAT ≤p HAMPATH. Kies één richting van het juistheidsbewijs.

**Gekozen richting**: Voorwaartse richting: Als $\phi$ satisfiable is, dan $\langle G, s, t \rangle \in \text{HAMPATH}$.

**Bewijs**:

- Stel dat $\phi = C_1 \wedge \ldots \wedge C_m$ satisfiable is, met een waarheidstoewijzing $\nu: \{x_1, \ldots, x_n\} \to \{0, 1\}$ die elke clause waar maakt.
- Construeer een Hamiltoniaans pad in $G$:
  1. Start bij $s$, ga naar $a\_{1,1}$.
  2. Voor elke variabele $x_i$ (i = 1, ..., $n$):
     - Als $\nu(x*i) = 1$, volg het "waar"-pad: $a*{i,1}, b*{i,1}, \ldots, b*{i,m}, a\_{i,m+1}$.
     - Als $\nu(x*i) = 0$, volg het "onwaar"-pad: $a*{i,1}, c*{i,1}, d*{i,1}, \ldots, d*{i,m}, c*{i,m+1}, a\_{i,m+1}$.
     - Ga naar de volgende variabele via $c*{i,m+1} \to a*{i+1,1}$ (voor $i < n$).
  3. Voor elke clause $c_j$, bezoek $e_j$:
     - Omdat $\nu$ $c_j$ waar maakt, is minstens één literal in $c_j$ waar.
     - Als $x*i \in c_j$ en $\nu(x_i) = 1$, bezoek $e_j$ via $(b*{i,j-1}, e*j, b*{i,j})$.
     - Als $\neg x*i \in c_j$ en $\nu(x_i) = 0$, bezoek $e_j$ via $(d*{i,j-1}, e*j, d*{i,j})$.
     - Kies één waar literal per clause om $e_j$ te bezoeken.
  4. Na de laatste variabele, ga van $c\_{n,m+1} \to t$.
- **Waarom is dit Hamiltoniaans**:
  - **Alle vertices bezocht**:
    - Variabele-structuren: Elke $x*i$-structuur wordt doorkruist via het waar- of onwaar-pad, en bezoekt alle $a*{i,j}, b*{i,j}, c*{i,j}, d\_{i,j}$.
    - Clause-vertices: Elke $e_j$ wordt precies één keer bezocht via een waar literal.
    - $s, t$: Bezocht aan begin en einde.
  - **Geen herhaling**:
    - Elke vertex heeft een unieke rol in het pad (diamantstructuren zijn lineair, clause-vertices worden één keer bezocht).
  - **Geldig pad**:
    - Alle bogen bestaan in $G$ (zoals gedefinieerd in de constructie).
- **Conclusie**: Het pad is een Hamiltoniaans pad van $s$ naar $t$, dus $\langle G, s, t \rangle \in \text{HAMPATH}$.

**Polynomiale reductie**:

- De constructie van $G$ is polynomiaal: $O(nm)$ vertices en bogen, en de reductie kan in tijd $O(nm)$ worden uitgevoerd.
- De correctheid (voorwaartse richting) toont dat $\phi$ satisfiable impliceert een Hamiltoniaans pad, wat een deel is van $\text{3SAT} \leq_p \text{HAMPATH}$.

#### (5) (15pt) Maak een polynomiale reductie van HAMPATH naar EHAMPATH.

**Definities**:

- **HAMPATH**: $\text{HAMPATH} = \{ \langle G, s, t \rangle \mid G \text{ is een gerichte graaf met een Hamiltoniaans pad van } s \text{ naar } t \}$, waarbij elke vertex precies één keer wordt bezocht.
- **EHAMPATH**: $\text{EHAMPATH} = \{ \langle G', s', t' \rangle \mid G' \text{ is een gerichte graaf met een pad van } s' \text{ naar } t' \text{ dat elke vertex minstens één keer bezoekt en elke boog maximaal één keer doorloopt} \}$.

**Reductie HAMPATH ≤p EHAMPATH**:
We construeren een polynomiale functie $f$ die een HAMPATH-instantie $\langle G, s, t \rangle$ omzet in een EHAMPATH-instantie $\langle G', s', t' \rangle$, zodanig dat:
$$
\langle G, s, t \rangle \in \text{HAMPATH} \iff \langle G', s', t' \rangle \in \text{EHAMPATH}.
$$

**Constructie**:

- **Input**: $G = (V, E)$, met $V = \{v_1, \ldots, v_n\}$, $s = v_1$, $t = v_n$.
- **Output**: $G' = (V', E')$, $s', t'$.
- **Graaf $G'$**:
  - **Vertices $V'$**:
    - Voor elke vertex $v_i \in V$, maak een vertex $v_i' \in V'$.
    - Voeg een extra vertex $w$ toe (een "hub" om bogen te beheren).
    - Dus, $V' = \{ v_1', \ldots, v_n', w \}$.
  - **Bogen $E'$**:
    - Voor elke boog $(v_i, v_j) \in E$, voeg een boog $(v_i', w) \in E'$ en $(w, v_j') \in E'$.
    - Voor elke vertex $v_i'$, voeg een boog $(v_i', w) \in E'$ (zelfs als $v_i$ geen uitgaande bogen heeft in $G$).
    - Voeg een boog $(w, v_1') \in E'$ toe (om het pad te starten).
  - **Start- en eindvertices**:
    - $s' = v_1'$.
    - $t' = v_n'$.

**Intuïtie**:

- In $G$, is een Hamiltoniaans pad een volgorde $v*1 \to v_2 \to \ldots \to v_n$ met $(v_i, v*{i+1}) \in E$.
- In $G'$, simuleert een pad dat elke vertex minstens één keer bezoekt en elke boog maximaal één keer gebruikt, een Hamiltoniaans pad in $G$. De hub $w$ splitst elke boog $(v_i, v_j)$ in $v_i' \to w \to v_j'$, en zorgt ervoor dat bogen in $G'$ slechts één keer worden gebruikt, terwijl vertices herhaaldelijk bezocht kunnen worden via $w$.

**Correctheid**:

- **Voorwaartse richting**: Als $\langle G, s, t \rangle \in \text{HAMPATH}$, dan $\langle G', s', t' \rangle \in \text{EHAMPATH}$.
  - Stel dat $G$ een Hamiltoniaans pad heeft: $v_1 \to v_2 \to \ldots \to v_n$.
  - Construeer een pad in $G'$:
    - Start bij $s' = v_1'$.
    - Volg: $v_1' \to w \to v_2' \to w \to v_3' \to \ldots \to w \to v_n'$.
    - Dit pad is:
      $$
      v_1' \to w \to v_2' \to w \to v_3' \to \ldots \to w \to v_n'.
     $$
  - **Eigenschappen**:
    - **Elke vertex minstens één keer**: Alle $v_i'$ (i = 1, ..., $n$) worden bezocht, en $w$ wordt meerdere keren bezocht (toegestaan in EHAMPATH).
    - **Elke boog maximaal één keer**: De bogen $(v*i', w)$ en $(w, v*{i+1}')$ worden elk precies één keer gebruikt, en $(w, v_1')$ wordt één keer gebruikt. Andere bogen worden niet gebruikt.
    - **Van $s'$ naar $t'$**: Het pad begint bij $v_1'$ en eindigt bij $v_n'$.
  - Dus, $\langle G', s', t' \rangle \in \text{EHAMPATH}$.
- **Omgekeerde richting**: Als $\langle G', s', t' \rangle \in \text{EHAMPATH}$, dan $\langle G, s, t \rangle \in \text{HAMPATH}$.
  - Stel dat $G'$ een pad heeft van $s' = v_1'$ naar $t' = v_n'$ dat elke vertex $\{v_1', \ldots, v_n', w\}$ minstens één keer bezoekt en elke boog maximaal één keer gebruikt.
  - Het pad moet de vorm hebben:
    - Start bij $v_1'$, dan naar $w$, dan naar een $v_i'$, dan naar $w$, enz., eindigend bij $v_n'$.
    - Omdat elke boog $(v_i', w)$ en $(w, v_j')$ maximaal één keer wordt gebruikt, kan elke $v_i'$ slechts één keer worden bezocht (anders zou $(v_i', w)$ of $(w, v_i')$ meerdere keren gebruikt worden).
  - Dus, het pad bezoekt elke $v*i'$ precies één keer, in een volgorde $v*{\pi(1)}' \to w \to v*{\pi(2)}' \to w \to \ldots \to v*{\pi(n)}'$, waarbij $\pi$ een permutatie is met $\pi(1) = 1$, $\pi(n) = n$.
  - Dit komt overeen met een pad in $G$: $v*1 \to v*{\pi(2)} \to \ldots \to v*n$, omdat elke overgang $v*{\pi(i)}' \to w \to v*{\pi(i+1)}'$ overeenkomt met een boog $(v*{\pi(i)}, v\_{\pi(i+1)}) \in E$ in $G$.
  - Omdat alle $v_i$ worden bezocht precies één keer, is dit een Hamiltoniaans pad in $G$.
  - Dus, $\langle G, s, t \rangle \in \text{HAMPATH}$.

**Polynomiale tijd**:

- **Constructie**:
  - $V'$: $n + 1$ vertices ($n$ voor $v_i'$, 1 voor $w$).
  - $E'$: Voor elke boog $(v_i, v_j) \in E$, maak $(v_i', w), (w, v_j')$. Plus $(v_i', w)$ voor elke $v_i$, en $(w, v_1')$. Totaal $O(n + m)$ bogen.
  - De constructie kost $O(n + m)$, polynomiaal in de grootte van $G$.
- **Grootte van $G'$**: Polynomiaal ($O(n^2)$ voor adjacency matrix, $O(n + m)$ voor adjacency lijst).

**Conclusie**: De reductie is polynomiaal en correct, dus $\text{HAMPATH} \leq_p \text{EHAMPATH}$.

# 1 Vraag 3: PATH(90pt)

(15pt) Leg uit wat NLOGSPACE betekent. Uit je antwoord moet duidelijk zijn wat voor Turing machines gebruikt worden. Kortom, laat zien dat je de onderliggende definities kent.

(20pt) We hebben gezien dat PATH = {<G,s,t> | er is een pad van s naar t in de gerichte graaf G.} een probleem is in NLOGSPACE. Beschrijf het algoritme voor PATH (in pseudocode) dat dit aantoont.

(25pt) Is PATH ook NLOGSPACE-compleet? Zoniet, argumenteer waarom. Zoja, beschrijf duidelijk wat je moet aantonen en geef het bewijs.

(10pt) Wat heeft de Stelling van Savitch als gevolg voor de deterministische plaatscomplexiteit van PATH? Meer bepaald, volgt hieruit dat PATH ook in LOGSPACE zit?

(10pt) Wat zegt de Stelling van Immerman-Szelepcsény over PATH?

(10pt) Ken je nog een andere NLOGSPACE-compleet probleem? Wees precies in de beschrijving van een dergelijk probleem (dus niet gewoon de naam van het probleem geven). Leg uit waarom je probleem in NLOGSPACE zit.

# 1 Vraag 4: PSPACE (100pt)

(15pt) Stel, je definieert PSPACE-compleetheid aan de hand van PSPACE-reducties. Toon aan dat elke niet-triviale taal in PSPACE dan compleet zal zijn. Geef een formeel bewijs. Waarom is dit niet gewenst? Wat is wel een goede definitie van PSPACE-compleetheid?

(15pt) We weten dat QBF een PSPACE-compleet probleem is. Leg in woorden het belang van de universele kwantoren uit in het PSPACE-hardheid bewijs. Wat kan je zeggen als er slechts existentiele kwantoren beschikbaar zijn?

(15pt) In het bewijs van de Stelling van Savitch laten we de procedure IsBereikbaar los op de configuratie graaf van de uitvoering van een Turing Machine M op een input woord w. Vul de volgende pseudo-code verder aan:
IsBereikbaar(c1, c2, t)
Als t=1, check [vul aan]
Als t > 1 dan [vul aan]
Voer IsBereikbaar([vul aan])
Voer IsBereikbaar([vul aan])
Als beiden aanvaarden, aanvaard.
Als nog niet aanvaard, verwerp.

(15pt) Volgend op vraag (3), hoe wordt uiteindelijk IsBereikbaar uitgevoerd in het bewijs van de Stelling van Savitch? Maak duidelijk wat het onderliggende idee is.

(20pt) Hoeveel plaats heeft IsBereikbaar nodig, wetende dat M O(s(n)) plaats nodig heeft. Leg uit.

(10pt) Is NP ⊆ PSPACE of PSPACE ⊆ NP? Leg uit.

(10pt) Wat kan je zeggen over de tijdscomplexiteit van problemen in PSPACE? Leg uit.
