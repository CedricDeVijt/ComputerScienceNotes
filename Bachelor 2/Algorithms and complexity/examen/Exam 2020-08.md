## 1.1 Vraag 1: PTIME en NP (5pt)

### (a) (1.5pt) Hoe wordt de $\Theta(t(n))$-tijdscomplexiteit van een niet-deterministische Turingmachine gedefinieerd? Hoe verschilt deze definitie van een deterministische Turingmachine? Wat is het belang van big-Theta en welke voorwaarde is nodig?

**Definitie van $\Theta(t(n))$-tijdscomplexiteit voor een niet-deterministische Turingmachine (NDTM)**:
Een NDTM $M$ heeft tijdscomplexiteit $\Theta(t(n))$ als er een functie $t(n)$ bestaat zodanig dat:

- Voor elke input $x$ van lengte $n$, de maximale lengte van een berekeningspad van $M$ op $x$ (over alle niet-deterministische keuzes) is zowel $\Omega(t(n))$ (ondergrens) als $O(t(n))$ (bovengrens).
- Formeel: Er bestaan constanten $c_1, c_2 > 0$ zodanig dat voor alle $n \geq n_0$, en voor elke input $x$ met $|x| = n$, de langste berekening van $M$ op $x$ (aantal stappen in de langste tak van de berekeningsboom) voldoet aan:
  $$
  c_1 \cdot t(n) \leq \text{maximale lengte van een berekeningspad} \leq c_2 \cdot t(n).
 $$
- Voor een NDTM betekent dit dat alle berekeningspaden (inclusief accepterende en verwerpende paden) in $\Theta(t(n))$ stappen worden voltooid, waarbij de machine een antwoord geeft (aanvaardt of verwerpt) afhankelijk van het bestaan van een accepterend pad.

**Definitie van $\Theta(t(n))$-tijdscomplexiteit voor een deterministische Turingmachine (DTM)**:
Een DTM $M$ heeft tijdscomplexiteit $\Theta(t(n))$ als:

- Voor elke input $x$ van lengte $n$, het aantal stappen dat $M$ uitvoert op $x$ zowel $\Omega(t(n))$ als $O(t(n))$ is.
- Formeel: Er bestaan constanten $c_1, c_2 > 0$ zodanig dat voor alle $n \geq n_0$, en voor elke input $x$ met $|x| = n$, het aantal stappen van $M$ op $x$ voldoet aan:
  $$
  c_1 \cdot t(n) \leq \text{aantal stappen} \leq c_2 \cdot t(n).
 $$
- Omdat een DTM slechts één berekeningspad heeft, wordt de tijdscomplexiteit bepaald door het exacte aantal stappen dat de machine uitvoert.

**Verschil tussen NDTM en DTM**:

- **NDTM**: De tijdscomplexiteit wordt gedefinieerd over de _langste tak_ in de berekeningsboom, omdat een NDTM meerdere paden kan volgen door niet-deterministische keuzes. Een NDTM aanvaardt als minstens één pad aanvaardt, maar de tijdscomplexiteit houdt rekening met de maximale lengte van alle paden om een uniforme maat te hebben.
- **DTM**: Er is slechts één berekeningspad, dus de tijdscomplexiteit is het exacte aantal stappen dat de machine uitvoert op de input.
- **Gevolg**: Voor een NDTM is de tijdscomplexiteit gebaseerd op de "slechtste" (langste) berekening, terwijl voor een DTM de tijdscomplexiteit direct het aantal stappen van het enige pad is.

**Belang van big-Theta ($\Theta$)**:

- **Waarom $\Theta$**: Het gebruik van $\Theta(t(n))$ geeft een _strakke grens_ voor de tijdscomplexiteit, wat betekent dat de looptijd zowel een bovengrens ($O(t(n))$) als een ondergrens ($\Omega(t(n))$) heeft. Dit is belangrijk om de complexiteit van een algoritme precies te karakteriseren, in plaats van alleen een bovengrens ($O$) of ondergrens ($\Omega$). Voor complexiteitsklassen zoals PTIME of NP is een precieze schatting nuttig om algoritmen te vergelijken.
- **Praktisch**: $\Theta$ zorgt ervoor dat we de groei van de looptijd exact beschrijven, wat essentieel is bij het vergelijken van deterministische en niet-deterministische algoritmen.

**Voorwaarde voor een goed gedefinieerde definitie**:

- De Turingmachine moet _halt_ op elke input, d.w.z. elke berekening (voor een DTM) of elk berekeningspad (voor een NDTM) moet eindigen in een accepterende of verwerpende toestand na een eindig aantal stappen. Dit zorgt ervoor dat de tijdscomplexiteit meetbaar is.
- Voor een NDTM moet de berekeningsboom eindig zijn, en alle paden moeten een gedefinieerde lengte hebben (geen oneindige lussen). Dit wordt gegarandeerd als de machine een tijdsgebonden functie $t(n)$ heeft die het maximum aantal stappen beperkt.

### (b) (1.5pt) Geef de definitie van NP, polynomiale tijd reduceerbaarheid, en NP-compleetheid. Geef een voorbeeld van een NP-complete taal.

**Definitie van NP**:
De complexiteitsklasse **NP** (Niet-deterministische Polynomiale tijd) bestaat uit alle talen $L \subseteq \Sigma^\*$ waarvoor een polynomiale verifiër bestaat. Formeel:

- Er is een deterministische Turingmachine $V$ en een polynomiale functie $p$, zodanig dat voor elke input $x$:
  - Als $x \in L$, er een certificaat $c$ bestaat met $|c| \leq p(|x|)$, zodat $V(x, c)$ aanvaardt in tijd $O(p(|x|))$.
  - Als $x \notin L$, geen certificaat $c$ bestaat zodat $V(x, c)$ aanvaardt.
- Intuïtief: Een probleem is in NP als een voorgestelde oplossing (certificaat) in polynomiale tijd kan worden geverifieerd.

**Definitie van polynomiale tijd reduceerbaarheid**:
Een taal $A \subseteq \Sigma^_$ is polynomiaal reduceerbaar naar een taal $B \subseteq \Sigma^_$, genoteerd als $A \leq*p B$, als er een polynomiaal tijd berekenbare functie $f: \Sigma^* \to \Sigma^\_$ bestaat zodanig dat voor elke $w \in \Sigma^\*$:
$$
w \in A \iff f(w) \in B.
$$
Dit betekent dat een instantie van $A$ in polynomiale tijd kan worden omgezet in een instantie van $B$, waarbij de oplossing behouden blijft.

**Definitie van NP-compleetheid**:
Een taal $A$ is **NP-compleet** als:

1. $A \in \text{NP}$: De taal is in NP (heeft een polynomiale verifiër).
2. $A$ is **NP-hard**: Elke taal $L \in \text{NP}$ is polynomiaal reduceerbaar naar $A$, d.w.z. $L \leq_p A$.

- Een NP-compleet probleem is dus een probleem in NP dat minstens zo moeilijk is als elk ander probleem in NP.

**Voorbeeld van een NP-complete taal**:
De taal **SAT** (Satisfiability) is NP-compleet. SAT = $\{ \langle \phi \rangle \mid \phi \text{ is een propositionele formule in CNF die satisfiable is} \}$. Dit werd bewezen door de Stelling van Cook-Levin, die aantoont dat SAT in NP zit en dat elk probleem in NP naar SAT kan worden gereduceerd.

### (c) (2pt) Beschrijf de taal 2SAT en toon aan dat deze taal in PTIME zit. Beschrijf het algoritme en toon één richting van het correctheidsbewijs.

**Beschrijving van 2SAT**:
De taal **2SAT** is gedefinieerd als:
$$
\text{2SAT} = \{ \langle \phi \rangle \mid \phi \text{ is een propositionele formule in CNF waarbij elke clause precies twee literals bevat en } \phi \text{ is satisfiable} \}.
$$
Bijvoorbeeld, $\phi = (x_1 \vee \neg x_2) \wedge (\neg x_1 \vee x_3) \wedge (x_2 \vee \neg x_3)$ is een 2SAT-formule.

**Algoritme voor 2SAT**:
Het algoritme voor 2SAT gebruikt een _implicatiegraaf_ om te bepalen of $\phi$ satisfiable is. Laat $\phi$ $n$ variabelen $x_1, \ldots, x_n$ en $m$ clauses hebben. Het algoritme werkt als volgt:

1. **Construeren van de implicatiegraaf** $G$:
   - Maak een gerichte graaf met $2n$ vertices: voor elke variabele $x_i$, maak vertices $x_i$ (voor $x_i = 1$) en $\neg x_i$ (voor $x_i = 0$).
   - Voor elke clause $(l_1 \vee l_2)$, voeg twee bogen toe:
     - $\neg l_1 \to l_2$: Als $l_1$ onwaar is, moet $l_2$ waar zijn.
     - $\neg l_2 \to l_1$: Als $l_2$ onwaar is, moet $l_1$ waar zijn.
     - Bijvoorbeeld, voor $(x_1 \vee \neg x_2)$, voeg bogen $(\neg x_1 \to \neg x_2)$ en $(x_2 \to x_1)$ toe.
2. **Vind sterk verbonden componenten (SCC’s)**:
   - Gebruik een algoritme zoals Kosaraju’s algoritme om de SCC’s van $G$ te vinden.
3. **Controleer consistentie**:
   - Als er een SCC bestaat die zowel $x_i$ als $\neg x_i$ bevat (voor enige $i$), verwerp, want dit betekent dat $x_i \equiv \neg x_i$, wat een contradictie is.
   - Als geen enkele SCC zowel $x_i$ als $\neg x_i$ bevat, aanvaard, want $\phi$ is satisfiable.
4. **Optioneel: Construeer een toewijzing**:
   - Geef een topologische ordening aan de SCC’s (in de componentgraaf).
   - Voor elke variabele $x_i$:
     - Als de SCC van $\neg x_i$ vóór die van $x_i$ komt in de topologische ordening, stel $x_i = 1$.
     - Anders, stel $x_i = 0$.

**Tijdscomplexiteit**:

- **Implicatiegraaf**: $O(n + m)$ (2n vertices, 2m bogen voor m clauses).
- **SCC’s vinden**: Kosaraju’s algoritme kost $O(n + m)$ (twee DFS-passen).
- **Consistentie controleren**: $O(n)$ (controleer elke $x_i, \neg x_i$).
- **Totaal**: $O(n + m)$, wat polynomiaal is in de inputgrootte ($O(n \log n + m)$ voor de codering van $\phi$).
- **Conclusie**: 2SAT $\in \text{PTIME}$.

**Correctheidsbewijs (voorwaartse richting: als $\phi$ satisfiable is, dan bevat geen SCC zowel $x_i$ als $\neg x_i$)**:

- Stel dat $\phi$ satisfiable is, met een waarheidstoewijzing $\nu: \{x_1, \ldots, x_n\} \to \{0, 1\}$ die elke clause waar maakt.
- In de implicatiegraaf $G$:
  - Voor elke clause $(l_1 \vee l_2)$, is minstens één literal waar onder $\nu$.
  - De bogen $\neg l_1 \to l_2$ en $\neg l_2 \to l_1$ betekenen dat als $l_1$ onwaar is, $l_2$ waar moet zijn, en omgekeerd.
- Stel dat er een SCC bestaat die zowel $x_i$ als $\neg x_i$ bevat. Dan bestaat er een gericht pad van $x_i \to \neg x_i$ en van $\neg x_i \to x_i$ in $G$.
  - Een pad $x_i \to \neg x_i$ betekent dat als $x_i = 1$, dan moet $\neg x_i = 1$, wat $x_i = 0$ impliceert (contradictie).
  - Dit impliceert dat $\nu$ geen consistente toewijzing kan zijn, omdat $x_i$ en $\neg x_i$ niet tegelijk waar kunnen zijn.
- Omdat $\nu$ $\phi$ satisfiable maakt, kan geen enkele SCC zowel $x_i$ als $\neg x_i$ bevatten, anders zou $\nu$ een contradictie opleveren.
- Dus, als $\phi$ satisfiable is, bevat geen SCC zowel $x_i$ als $\neg x_i$, en het algoritme aanvaardt correct.

**Opmerking**: De omgekeerde richting (als geen SCC zowel $x_i$ als $\neg x_i$ bevat, dan is $\phi$ satisfiable) zou tonen dat een consistente toewijzing kan worden geconstrueerd, maar we hebben de voorwaartse richting gekozen.

## 1.2 Vraag 2: CLIQUE (5pt)

### (a) (1pt) Beschrijf het CLIQUE probleem en toon aan dat CLIQUE in NP zit door middel van een polynomiale verifiër.

**Beschrijving van CLIQUE**:
Het CLIQUE beslissingsprobleem is gedefinieerd als:
$$
\text{CLIQUE} = \{ \langle G, k \rangle \mid G \text{ is een ongerichte graaf met een clique van grootte } k \}.
$$
Een clique in een graaf $G = (V, E)$ is een deelverzameling van vertices $S \subseteq V$ zodanig dat elke twee vertices in $S$ verbonden zijn door een boog in $E$. Het probleem vraagt of $G$ een clique heeft van minstens $k$ vertices.

**Bewijs dat CLIQUE ∈ NP**:
We tonen aan dat CLIQUE in NP zit door een polynomiale verifiër te construeren.

- **Certificaat**: Het certificaat $c$ is een deelverzameling $S \subseteq V$ van $k$ vertices, voorgesteld als een lijst van vertex-ID’s.
- **Verifiër V**:
  1. Input: $\langle G, k \rangle$ en certificaat $c$ (verzameling $S$).
  2. Controleer of $|S| = k$ (de grootte van $S$ is $k$).
  3. Controleer of $S$ een clique is:
     - Voor elk paar vertices $u, v \in S$ (met $u \neq v$), controleer of $(u, v) \in E$.
  4. Als alle controles slagen, aanvaard; anders verwerp.
- **Tijdscomplexiteit**:
  - **Inputgrootte**: $n = |V|$, $m = |E|$. De grootte van $\langle G, k \rangle$ is $O(n^2)$ (adjacency matrix) of $O(n + m)$ (adjacency lijst).
  - **Stap 2**: Controleer $|S| = k$: $O(n)$.
  - **Stap 3**: Controleer alle paren in $S$: Er zijn $\binom{k}{2} \leq k^2 \leq n^2$ paren. Per paar kost het $O(1)$ (adjacency matrix) of $O(n)$ (adjacency lijst) om te controleren of $(u, v) \in E$.
    - Totaal: $O(n^2)$ (matrix) of $O(n^3)$ (lijst).
  - **Totaal**: Polynomiaal ($O(n^2)$ of $O(n^3)$).
- **Correctheid**:
  - Als $\langle G, k \rangle \in \text{CLIQUE}$, bestaat er een clique $S$ van grootte $k$. De verifiër aanvaardt $V(\langle G, k \rangle, S)$.
  - Als $\langle G, k \rangle \notin \text{CLIQUE}$, is geen $S$ van grootte $k$ een clique, en de verifiër verwerpt voor elk certificaat.
- **Conclusie**: CLIQUE $\in \text{NP}$.

### (b) (1.5pt) Beschrijf kort de reductie 3SAT ≤p CLIQUE en illustreer dit voor $\phi = (x_1 \vee \neg x_2 \vee x_4) \wedge (\neg x_1 \vee x_3 \vee \neg x_4) \wedge (x_2 \vee \neg x_3 \vee x_4)$.

**Beschrijving van de reductie 3SAT ≤p CLIQUE**:
De reductie zet een 3SAT-formule $\phi$ met $n$ variabelen en $m$ clauses om in een instantie $\langle G, k \rangle$ van CLIQUE, zodanig dat $\phi$ satisfiable is als en slechts als $G$ een clique heeft van grootte $k$.

- **Constructie**:
  - **Graaf $G = (V, E)$**:
    - Voor elke literal in elke clause van $\phi$, maak een vertex. Voor clause $c*j = (l*{j,1} \vee l*{j,2} \vee l*{j,3})$, maak vertices $v*{j,1}, v*{j,2}, v*{j,3}$, waarbij $v*{j,i}$ overeenkomt met literal $l\_{j,i}$.
    - Voeg een boog $(v*{j,i}, v*{j',i'})$ toe tussen twee vertices als:
      - Ze behoren tot verschillende clauses ($j \neq j'$).
      - De literals niet contradictorisch zijn (d.w.z. niet $x_i$ en $\neg x_i$).
  - **Parameter $k$**: Stel $k = m$, het aantal clauses.
- **Intuïtie**:
  - Een clique van grootte $m$ in $G$ komt overeen met het kiezen van één waar literal per clause, zodanig dat de gekozen literals consistent zijn (geen contradicties zoals $x_i = 1$ en $x_i = 0$).
  - De afwezigheid van bogen tussen contradictorische literals zorgt ervoor dat een clique een consistente toewijzing vertegenwoordigt.
- **Polynomiale tijd**: De graaf heeft $3m$ vertices en $O(m^2)$ bogen. De constructie kost $O(m^2)$.

**Illustratie voor $\phi = (x_1 \vee \neg x_2 \vee x_4) \wedge (\neg x_1 \vee x_3 \vee \neg x_4) \wedge (x_2 \vee \neg x_3 \vee x_4)$**:

- **Variabelen**: $x_1, x_2, x_3, x_4$ ($n = 4$).
- **Clauses** ($m = 3$):
  - $c_1 = (x_1 \vee \neg x_2 \vee x_4)$
  - $c_2 = (\neg x_1 \vee x_3 \vee \neg x_4)$
  - $c_3 = (x_2 \vee \neg x_3 \vee x_4)$
- **Graaf $G$**:
  - **Vertices** (9 vertices):
    - Voor $c*1$: $v*{1,1} = x*1, v*{1,2} = \neg x*2, v*{1,3} = x_4$.
    - Voor $c*2$: $v*{2,1} = \neg x*1, v*{2,2} = x*3, v*{2,3} = \neg x_4$.
    - Voor $c*3$: $v*{3,1} = x*2, v*{3,2} = \neg x*3, v*{3,3} = x_4$.
  - **Bogen**:
    - Verbind elke vertex $v*{j,i}$ met elke vertex $v*{j',i'}$ (waar $j \neq j'$) tenzij de literals contradictorisch zijn:
      - Contradicties: $(x_1, \neg x_1), (x_2, \neg x_2), (x_3, \neg x_3), (x_4, \neg x_4)$.
    - Voorbeelden van bogen:
      - $(v*{1,1}, v*{2,2}) = (x_1, x_3)$: Niet contradictorisch, verschillende clauses.
      - $(v*{1,2}, v*{3,3}) = (\neg x_2, x_4)$: Niet contradictorisch.
      - Geen boog: $(v*{1,1}, v*{2,1}) = (x_1, \neg x_1)$: Contradictorisch.
  - **Parameter**: $k = m = 3$.
- **Resultaat**: $\langle G, 3 \rangle$, waar $G$ een clique van grootte 3 heeft als $\phi$ satisfiable is.

### (c) (1.5pt) Toon de juistheid van de reductie 3SAT ≤p CLIQUE aan. Kies één richting van het juistheidsbewijs.

**Gekozen richting**: Voorwaartse richting: Als $\phi$ satisfiable is, dan heeft $G$ een clique van grootte $k = m$.

**Bewijs**:

- Stel dat $\phi$ satisfiable is, met een waarheidstoewijzing $\nu: \{x_1, \ldots, x_n\} \to \{0, 1\}$ die elke clause $c_j$ waar maakt.
- Construeer een clique $S \subseteq V$ in $G$:
  - Voor elke clause $c*j = (l*{j,1} \vee l*{j,2} \vee l*{j,3})$, kies één literal $l\_{j,i}$ die waar is onder $\nu$. (Omdat $\nu$ $c_j$ waar maakt, bestaat minstens één waar literal.)
  - Voeg de corresponderende vertex $v\_{j,i}$ toe aan $S$.
  - Omdat er $m$ clauses zijn, bevat $S$ precies $m$ vertices (één per clause).
- **Is $S$ een clique?**
  - Voor elk paar vertices $v*{j,i}, v*{j',i'} \in S$ (met $j \neq j'$):
    - $v*{j,i}$ en $v*{j',i'}$ komen uit verschillende clauses ($j \neq j'$).
    - De literals $l*{j,i}$ en $l*{j',i'}$ zijn beide waar onder $\nu$, dus ze kunnen niet contradictorisch zijn (bijv. $x_i$ en $\neg x_i$).
      - Als $l*{j,i} = x_i$ en $l*{j',i'} = \neg x*i$, dan zou $\nu(x_i) = 1$ (voor $l*{j,i}$) en $\nu(x*i) = 0$ (voor $l*{j',i'}$), een contradictie.
    - Omdat de literals niet contradictorisch zijn en uit verschillende clauses komen, bestaat er een boog $(v*{j,i}, v*{j',i'})$ in $G$.
  - Dus, elke twee vertices in $S$ zijn verbonden, en $S$ is een clique van grootte $m$.
- **Conclusie**: Als $\phi$ satisfiable is, heeft $G$ een clique van grootte $k = m$, dus $\langle G, k \rangle \in \text{CLIQUE}$.

### (d) (1pt) Geef een voorbeeld van een probleem X zodat CLIQUE ≤p X. Wat betekent dit voor X? Welke eigenschap van reducties gebruik je?

**Voorbeeld van probleem X**:
Een voorbeeld van een probleem $X$ waarvoor $\text{CLIQUE} \leq_p X$ is **VERTEX-COVER**.

- **VERTEX-COVER**: $\text{VERTEX-COVER} = \{ \langle G, k \rangle \mid G \text{ is een ongerichte graaf met een vertex cover van grootte } \leq k \}$. Een vertex cover is een verzameling $S \subseteq V$ zodanig dat elke boog in $E$ minstens één eindpunt in $S$ heeft.

**Betekenis voor X**:

- Dat $\text{CLIQUE} \leq_p \text{VERTEX-COVER}$ betekent dat er een polynomiale reductie bestaat van CLIQUE naar VERTEX-COVER. Als VERTEX-COVER in polynomiale tijd oplosbaar is (d.w.z. $\text{VERTEX-COVER} \in \text{PTIME}$), dan is CLIQUE dat ook, omdat een instantie van CLIQUE in polynomiale tijd kan worden omgezet in een instantie van VERTEX-COVER.
- Omdat CLIQUE NP-compleet is, impliceert $\text{CLIQUE} \leq_p \text{VERTEX-COVER}$ dat VERTEX-COVER minstens zo moeilijk is als CLIQUE. Aangezien CLIQUE NP-hard is, is VERTEX-COVER ook NP-hard. Bovendien, omdat VERTEX-COVER $\in \text{NP}$, is VERTEX-COVER NP-compleet.

**Gebruikte eigenschap van reducties**:

- **Transitiviteit van polynomiale reducties**: Als $A \leq_p B$, en $A$ is NP-hard, dan is $B$ ook NP-hard. Dit volgt omdat een polynomiale reductie van $A$ naar $B$ betekent dat een oplossing voor $B$ in polynomiale tijd een oplossing voor $A$ oplevert. Aangezien CLIQUE NP-compleet is (en dus NP-hard), maakt de reductie $\text{CLIQUE} \leq_p \text{VERTEX-COVER}$ VERTEX-COVER NP-hard.
- **NP-compleetheid van VERTEX-COVER**: De reductie bevestigt dat VERTEX-COVER NP-compleet is, omdat het zowel NP-hard is (door de reductie) als in NP zit (een vertex cover kan in polynomiale tijd worden geverifieerd).

## 1.3 Vraag 3: PSPACE en NPSPACE (5pt)

(1pt) Formuleer de Stelling van Savitch en toon formeel aan wat hieruit volgt voor de klassen PSPACE en NPSPACE.

(3pt) In het bewijs van de Stelling van Savitch laten we de procedure IsBereikbaar los op de configuratie graaf van de uitovering van een Turing Machine M op een input woord w. Antwoord de volgende vragen:
Vul de volgende pseudo-code aan:

```
IsBereikbaar(c1, c2, t)
Als t=1, check [vul aan]
Als t > 1 dan [vul aan]
  Voer IsBereikbaar([vul aan])
  Voer IsBereikbaar([vul aan])
Als beiden aanvaarden, aanvaard.
Als nog niet aanvaard, verwerp.
```

Hoe wordt uiteindelijk IsBereikbaar uitgevoerd in het bewijs van de Stelling van Savitch? Maak duidelijk wat het onderliggende idee is.
Hoeveel plaats heeft IsBereikbaar nodig, wetende dat de input een θ(s(n)) -plaats niet-deterministische Turing machine is? Leg zo gedetailleerd mogelijk uit.

(1pt) Is NP ⊆ PSPACE of PSPACE ⊆ NP? Wat kan je verder zeggen over de tijdscomplexiteit van problemen in PSPACE? Leg uit.

## 1.4 Vraag 4: LOGSPACE en NLOGSPACE (5pt)

(1.5pt) Beschrijf waarom A⩽LB en B⩽LC impliceert dat A⩽LC (transitiviteit). Uit je antwoord moet duidelijk zijn dat je weet wat LOGSPACE reducties zijn en waarom transitiviteit van dergelijke reducties niet vanzelfsprekend is.

(1.5pt) Beschouw de onderstaande graaf G. Zoals je ziet zijn er vier knopen bereikbaar vanuit s: s, u, v en w. De knoop t is niet bereikbaar. Wetende dat er vier knopen bereikbaar zijn vanuit s, laat een succesvolle "run" zien op deze graaf van het algoritme dat PATH⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ beslist in het bewijs van de Stelling van Immerman-Szelepcsényi. Met andere woorden check dat t niet bereikbaar is. Analyseer de plaatscomplexitiet.
Graphviz.png

(1pt) Toon aan dat PATH NLOGSPACE-hard. In je uitleg, beschrijf duidelijk waarom de gebruikte reductie een LOGSPACE-reductie is.

(1pt) Wetende dat PATH NLOGSPACE-compleet is, leg uit hoe hieruit volgt dat 2SAT ook NLOGSPACE-compleet is. In je antwoord is het voldoende om uit te leggen op welke manieren we dit hebben aangetoond in de les. Met andere woorden, voor welk probleem hebben we lidmaatschap in NLOGSPACE aangetoond, van welk probleem hebben we een LOGSPACE-reductie gemaakt, en hoe volgt hieruit dat 2SAT ook NLOGSPACE-compleet is?
