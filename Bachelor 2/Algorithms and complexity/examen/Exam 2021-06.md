## Vraag 1: NP (7pt)

### (a) (1.5pt) Geef de definitie van een polynomiale tijd berekenbare functie en definieer hiermee polynomiale reduceerbaarheid van een taal A naar een taal B.

**Definitie van een polynomiale tijd berekenbare functie**:
Een functie $f: \Sigma^* \to \Sigma^*$ is polynomiaal tijd berekenbaar als er een deterministische Turingmachine M bestaat die, op input $w \in \Sigma^*$, de output $f(w)$ berekent in tijd $O(p(|w|))$, waarbij $p$ een polynomiale functie is en $|w|$ de lengte van de input is. Met andere woorden, de berekening van $f(w)$ kost polynomiaal veel stappen in verhouding tot de lengte van $w$.

**Definitie van polynomiale reduceerbaarheid**:
Een taal $A \subseteq \Sigma^*$ is polynomiaal reduceerbaar naar een taal $B \subseteq \Sigma^*$, genoteerd als $A \leq_p B$, als er een polynomiaal tijd berekenbare functie $f: \Sigma^* \to \Sigma^*$ bestaat zodanig dat voor elke $w \in \Sigma^*$:

$$
w \in A \iff f(w) \in B.
$$

Dit betekent dat een instantie $w$ van probleem $A$ in polynomiale tijd kan worden omgezet in een instantie $f(w)$ van probleem $B$, zodat het antwoord op $f(w) \in B$ hetzelfde is als $w \in A$. De reductie zorgt ervoor dat als $B$ in polynomiale tijd oplosbaar is, $A$ dat ook is.

### (b) (1.5pt) Leg uit wat NP-compleetheid is. Geef de definitie zo volledig mogelijk.

**Definitie van NP-compleetheid**:
Een taal $A$ is **NP-compleet** als:

1. **$A \in \text{NP}$**: De taal $A$ behoort tot de complexiteitsklasse NP, wat betekent dat er een polynomiale verifiër bestaat. Formeel: er is een deterministische Turingmachine $V$ en een polynomiale functie $p$, zodanig dat voor elke input $x$:
   - Als $x \in A$, er een certificaat $c$ bestaat met $|c| \leq p(|x|)$, zodat $V(x, c)$ aanvaardt in polynomiale tijd.
   - Als $x \notin A$, geen certificaat $c$ bestaat zodat $V(x, c)$ aanvaardt.
2. **$A$ is NP-hard**: Elke taal $L \in \text{NP}$ is polynomiaal reduceerbaar naar $A$, d.w.z. $L \leq_p A$. Dit betekent dat $A$ minstens zo moeilijk is als elk probleem in NP, omdat een oplossing voor $A$ in polynomiale tijd een oplossing voor elk NP-probleem oplevert via een polynomiale reductie.

**Betekenis**:

- NP-complete problemen zijn de "moeilijkste" problemen in NP. Als er een polynomiaal algoritme wordt gevonden voor één NP-compleet probleem, volgt dat $\text{P} = \text{NP}$, omdat alle NP-problemen dan in polynomiale tijd oplosbaar zijn.
- Voorbeelden van NP-complete problemen zijn SAT, 3SAT, HAMPATH, en SUBSETSUM.

### (c) (3pt) In het bewijs dat SAT NP-hard is, wordt een reductie beschreven die een formule van de vorm $\phi = \phi_{\text{cell}} \wedge \phi_{\text{start}} \wedge \phi_{\text{move}} \wedge \phi_{\text{accept}}$ genereert. Leg uit:

- **Wat het betekent als een truth assignment deze formules waar maakt. Geef de betekenis hiervan voor elk van de vier formules apart.**
- **Leg in meer detail uit hoe $\phi_{\text{move}}$ gedefinieerd wordt en waarom deze “werkt”.**

**Betekenis van een truth assignment die de formules waar maakt**:
De formule $\phi = \phi_{\text{cell}} \wedge \phi_{\text{start}} \wedge \phi_{\text{move}} \wedge \phi_{\text{accept}}$ wordt geconstrueerd om de werking van een polynomiale verifiër $V$ voor een taal $L \in \text{NP}$ te simuleren op input $x$ met een certificaat $c$. Een truth assignment $\nu$ die $\phi$ waar maakt, beschrijft een geldige accepterende berekening van $V$ op $x$ met een geschikt certificaat. De betekenis van elke component is als volgt:

1. **$\phi_{\text{cell}}$**:

   - **Betekenis**: Deze formule zorgt ervoor dat de configuraties van de Turingmachine consistent zijn, d.w.z. dat op elk tijdstip $t$ (0 ≤ $t \leq p(n)$) en elke tape-positie $i$ (0 ≤ $i \leq p(n)$) precies één symbool uit het tape-alfabet $\Gamma$ (inclusief blanco) of één toestand $q \in Q$ aanwezig is.
   - **Truth assignment**: Een toewijzing $\nu$ maakt $\phi_{\text{cell}}$ waar als de variabelen (die de inhoud van de tape en de toestand op elk tijdstip en positie vertegenwoordigen) consistent zijn. Bijvoorbeeld, een variabele $x*{t,i,a}$ is waar als op tijd $t$, positie $i$, symbool $a$ aanwezig is, en precies één zo’n variabele per $(t, i)$ is waar.

2. **$\phi_{\text{start}}$**:

   - **Betekenis**: Deze formule stelt dat de initiële configuratie van $V$ correct is, d.w.z. de Turingmachine start in de begintoestand $q_0$, de kop staat op positie 0, en de tape bevat de input $x$ gevolgd door een certificaat $c$ en blanco’s.
   - **Truth assignment**: Een toewijzing $\nu$ maakt $\phi_{\text{start}}$ waar als de variabelen die de initiële configuratie beschrijven (bij $t = 0$) overeenkomen met de starttoestand, de input $x$, en een geldig certificaat.

3. **$\phi_{\text{move}}$**:

   - **Betekenis**: Deze formule zorgt ervoor dat elke stap van de Turingmachine overeenkomt met een geldige overgang volgens de transitiefunctie $\delta$ van $V$. Het garandeert dat de configuratie op tijd $t+1$ volgt uit de configuratie op tijd $t$.
   - **Truth assignment**: Een toewijzing $\nu$ maakt $\phi_{\text{move}}$ waar als de variabelen die de toestand, tape-inhoud, en koppositie op tijd $t+1$ beschrijven, consistent zijn met de toepassing van $\delta$ op de configuratie op tijd $t$.

4. **$\phi_{\text{accept}}$**:
   - **Betekenis**: Deze formule stelt dat de Turingmachine uiteindelijk een accepterende toestand bereikt binnen $p(n)$ stappen.
   - **Truth assignment**: Een toewijzing $\nu$ maakt $\phi_{\text{accept}}$ waar als er een tijdstip $t \leq p(n)$ en een positie $i$ bestaat waar de variabele die een accepterende toestand $q*{\text{accept}}$ vertegenwoordigt waar is.

**Uitleg van $\phi_{\text{move}}$**:

- **Definitie**:

  - $\phi_{\text{move}}$ wordt gedefinieerd om te garanderen dat de overgangen tussen configuraties van de Turingmachine $V$ correct zijn volgens de transitiefunctie $\delta$. Voor een deterministische Turingmachine is $\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$, waarbij $\delta(q, a) = (q', b, d)$ betekent: in toestand $q$, bij het lezen van symbool $a$, ga naar toestand $q'$, schrijf symbool $b$, en beweeg de kop naar links ($L$) of rechts ($R$).
  - $\phi_{\text{move}}$ bestaat uit clauses die lokale consistentie afdwingen voor elke tijdstap $t$ (0 ≤ $t < p(n)$) en elke positie $i$. Het idee is om een "venster" van drie tape-posities ($i-1, i, i+1$) rond de kop te controleren, omdat de transitie alleen de huidige positie $i$ (waar de kop is) en de aangrenzende posities beïnvloedt (afhankelijk van de beweging $L$ of $R$).
  - Voor elke mogelijke configuratie van toestand $q$, symbool $a$ op positie $i$, en symbolen op $i-1$ en $i+1$, worden clauses gegenereerd die ervoor zorgen dat:
    - Als op tijd $t$, positie $i$ in toestand $q$ is en symbool $a$ leest, dan op tijd $t+1$, de nieuwe toestand, symbool, en koppositie overeenkomen met $\delta(q, a)$.
    - Posities die niet door de kop worden beïnvloed (buiten het venster) blijven ongewijzigd.
  - Formeel worden variabelen zoals $x*{t,i,a}$ (symbool $a$ op tijd $t$, positie $i$) en $q*{t,i,q}$ (toestand $q$ op tijd $t$, positie $i$) gebruikt om deze consistentie uit te drukken.

- **Waarom werkt $\phi_{\text{move}}$**:
  - $\phi_{\text{move}}$ "werkt" omdat het de werking van de Turingmachine stap voor stap simuleert in de vorm van logische constraints. Elke clause in $\phi_{\text{move}}$ controleert of een overgang van configuratie $C*t$ naar $C*{t+1}$ geldig is volgens $\delta$. Bijvoorbeeld:
    - Als de kop op positie $i$ staat in toestand $q$, leest symbool $a$, en $\delta(q, a) = (q', b, R)$, dan moeten de variabelen op tijd $t+1$ aangeven dat:
      - Positie $i$ nu symbool $b$ bevat.
      - De kop naar positie $i+1$ is verplaatst, en de machine in toestand $q'$ is.
      - Positie $i-1$ en andere onveranderde posities behouden hun symbool.
  - Door deze constraints voor alle tijdstippen en posities te combineren, zorgt $\phi_{\text{move}}$ ervoor dat een truth assignment die $\phi_{\text{move}}$ waar maakt, overeenkomt met een geldige berekening van $V$. Als er een accepterende berekening bestaat, zal een toewijzing die deze berekening beschrijft alle clauses in $\phi_{\text{move}}$ (en de andere formules) satisfiëren, waardoor $\phi$ satisfiable is.

**Samenvattend**: $\phi_{\text{move}}$ vertaalt de mechanica van de Turingmachine naar een reeks logische voorwaarden, die garanderen dat elke stap in de berekening correct is. Dit maakt het mogelijk om de vraag "bestaat er een accepterende berekening?" te herformuleren als "is $\phi$ satisfiable?".

### (d) (1pt) Is de redenering dat 3SAT NP-compleet is omdat elke 3SAT-formule ook een SAT-formule is, juist?

**Redenering**: "Aangezien elke 3SAT-formule ook een SAT-formule is, volgt uit de Stelling van Cook-Levin dat 3SAT dan ook NP-compleet is."

**Analyse**:
De redenering is **onjuist** omdat het feit dat 3SAT een speciaal geval van SAT is (elke 3SAT-formule is een SAT-formule waarbij elke clause precies drie literals bevat) niet voldoende is om direct te concluderen dat 3SAT NP-compleet is. De Stelling van Cook-Levin bewijst dat SAT NP-compleet is, maar om aan te tonen dat 3SAT NP-compleet is, moet expliciet worden voldaan aan de twee voorwaarden van NP-compleetheid:

1. **3SAT ∈ NP**: Dit is waar, omdat een 3SAT-formule een speciale vorm van een SAT-formule is, en SAT ∈ NP (een certificaat is een waarheidstoewijzing die in polynomiale tijd kan worden geverifieerd).
2. **3SAT is NP-hard**: Dit vereist dat elk probleem in NP polynomiaal reduceerbaar is naar 3SAT ($L \leq_p \text{3SAT}$). De Stelling van Cook-Levin toont aan dat elk probleem in NP reduceerbaar is naar SAT, maar niet automatisch naar 3SAT, omdat 3SAT een striktere vorm heeft (clauses met precies drie literals).

**Waarom is de redenering onjuist**:

- Het feit dat 3SAT een subset is van SAT garandeert niet dat 3SAT NP-hard is. Een eenvoudiger probleem (bijv. 2SAT) is ook een subset van SAT, maar 2SAT is in PTIME en dus niet NP-compleet (tenzij $\text{P} = \text{NP}$).
- Om 3SAT NP-compleet te bewijzen, is een expliciete reductie nodig, zoals SAT $\leq_p$ 3SAT, waarbij een algemene SAT-formule wordt omgezet in een equivalente 3SAT-formule. Deze reductie (zie cursusmateriaal) transformeert clauses met meer of minder dan drie literals naar clauses met precies drie literals door extra variabelen en clauses toe te voegen, terwijl de satisfiability behouden blijft.

**Formele argumentatie**:

- **3SAT ∈ NP**: Een 3SAT-formule $\phi$ kan in polynomiale tijd worden geverifieerd door een waarheidstoewijzing $\nu$ te controleren (O(m) tijd, waar m het aantal clauses is).
- **3SAT is NP-hard**: Dit wordt bewezen door een polynomiale reductie van SAT naar 3SAT. Voor een SAT-formule $\phi$ met clauses van willekeurige grootte wordt een 3SAT-formule $\phi'$ geconstrueerd:
  - Voor een clause met $k > 3$ literals, introduceer nieuwe variabelen en splits de clause in meerdere clauses met drie literals.
  - Voor een clause met $k < 3$ literals, voeg dummy-variabelen toe om precies drie literals te krijgen.
  - Deze reductie is polynomiaal en behoudt satisfiability.
- Omdat SAT NP-compleet is (door Cook-Levin) en SAT $\leq_p$ 3SAT, is 3SAT NP-hard. Samen met 3SAT ∈ NP volgt dat 3SAT NP-compleet is.

**Conclusie**: De redenering is onjuist omdat NP-compleetheid van 3SAT een expliciete reductie vereist, niet alleen het feit dat 3SAT een speciaal geval van SAT is.

## Vraag 2: HAMPATH (5pt)

### (a) (1.5pt) Beschrijf het HAMPATH beslissingsprobleem en toon aan dat HAMPATH in NP zit door middel van een niet-deterministische Turingmachine. Beschrijf de Turingmachine in pseudo-code en analyseer de tijdscomplexiteit.

**Beschrijving van HAMPATH**:
Het HAMPATH beslissingsprobleem is gedefinieerd als:

$$
\text{HAMPATH} = \{ \langle G, s, t \rangle \mid G \text{ is een gerichte graaf met een Hamiltoniaans pad van vertex } s \text{ naar } t \}.
$$

Een Hamiltoniaans pad in een gerichte graaf $G = (V, E)$ is een pad dat elke vertex in $V$ precies één keer bezoekt, beginnend bij $s$ en eindigend bij $t$.

**Bewijs dat HAMPATH ∈ NP**:
We tonen aan dat HAMPATH in NP zit door een niet-deterministische Turingmachine (NDTM) te beschrijven die in polynomiale tijd beslist of $\langle G, s, t \rangle \in \text{HAMPATH}$.

**Pseudo-code van de NDTM**:

```
M = "Op input ⟨G, s, t⟩, waar G = (V, E) een gerichte graaf is, s, t ∈ V":
1. Niet-deterministisch gok een volgorde van vertices P = [v₁, v₂, ..., vₙ], waarbij v₁ = s, vₙ = t, en n = |V|.
2. Controleer of P een geldig Hamiltoniaans pad is:
   a. Controleer of P alle vertices in V precies één keer bevat (gebruik een verzameling om duplicaten te detecteren).
   b. Voor i = 1 tot n-1, controleer of (vᵢ, vᵢ₊₁) ∈ E (de boog bestaat in G).
3. Als alle controles slagen, aanvaard; anders verwerp.
```

**Werking**:

- In stap 1 "gokt" de NDTM niet-deterministisch een permutatie van de vertices, beginnend bij $s$ en eindigend bij $t$. Dit simuleert het kiezen van een mogelijk Hamiltoniaans pad.
- In stap 2 wordt gecontroleerd of:
  - De volgorde $P$ een geldige permutatie is van alle vertices (elke vertex precies één keer).
  - Elke overgang $(v*i, v*{i+1})$ een boog is in $G$.
- Als beide voorwaarden voldaan zijn, is $P$ een Hamiltoniaans pad, en de machine aanvaardt.

**Tijdscomplexiteitanalyse**:

- **Inputgrootte**: De graaf $G$ heeft $n = |V|$ vertices en $m = |E|$ bogen. De input $\langle G, s, t \rangle$ heeft grootte $O(n^2)$ (bijv. via een adjacency matrix) of $O(m \log n)$ (bij een adjacency lijst).
- **Stap 1**: Het niet-deterministisch gokken van een volgorde $P$ van $n$ vertices kost geen tijd in een NDTM (het wordt gedaan in één niet-deterministische stap). De opslag van $P$ is $O(n)$.
- **Stap 2a**: Controleer of $P$ alle vertices precies één keer bevat:
  - Gebruik een hashset om te controleren op duplicaten en volledigheid: $O(n)$ tijd.
- **Stap 2b**: Controleer of elke $(v*i, v*{i+1}) \in E$:
  - Voor $n-1$ bogen, controleer of elke boog bestaat. Bij een adjacency matrix kost dit $O(1)$ per boog, dus $O(n)$ totaal. Bij een adjacency lijst kost het $O(\log n)$ per boog (voor zoeken), dus $O(n \log n)$.
- **Totale tijd**: $O(n)$ (adjacency matrix) of $O(n \log n)$ (adjacency lijst). Beide zijn polynomiaal in de inputgrootte.

**Conclusie**: De NDTM beslist in polynomiale tijd of er een Hamiltoniaans pad bestaat. Omdat een NDTM die in polynomiale tijd aanvaardt overeenkomt met een probleem in NP, zit HAMPATH in NP.

### (b) (2.5pt) Beschrijf de reductie 3SAT ≤P HAMPATH en toon de juistheid van de reductie aan. Kies één richting van het juistheidsbewijs en schrijf duidelijk welke richting je aantoont. Veronderstel dat de gegeven 3SAT-formule uit m clauses bestaat en n variabelen.

**Beschrijving van de reductie 3SAT ≤P HAMPATH** (zie cursusmateriaal, bijv. pagina 118):
De reductie zet een 3SAT-formule $\phi$ met $n$ variabelen $x_1, \ldots, x_n$ en $m$ clauses $c_1, \ldots, c_m$ om in een instantie $\langle G, s, t \rangle$ van HAMPATH, zodanig dat $\phi$ satisfiable is als en slechts als $G$ een Hamiltoniaans pad heeft van $s$ naar $t$.

**Constructie van de graaf $G$**:

- **Vertices**:
  - Twee speciale vertices: startvertex $s$ en eindvertex $t$.
  - Voor elke variabele $x_i$ (i = 1, ..., n): Maak een "diamantstructuur" met $2m + 2$ vertices, verdeeld in twee paden (voor $x_i = \text{waar}$ en $x_i = \text{onwaar}$):
    - Pad voor $x*i = \text{waar}$: $a*{i,1}, b*{i,1}, b*{i,2}, \ldots, b*{i,m}, a*{i,m+1}$.
    - Pad voor $x*i = \text{onwaar}$: $c*{i,1}, d*{i,1}, d*{i,2}, \ldots, d*{i,m}, c*{i,m+1}$.
    - Verbind $a*{i,1}$ met $c*{i,1}$ en $a*{i,m+1}$ met $c*{i,m+1}$ om een lus te vormen.
  - Voor elke clause $c_j$ (j = 1, ..., m): Maak een vertex $e_j$.
- **Bogen**:
  - **Binnen variabele-structuren**:
    - Voor $x*i = \text{waar}$: Bogen $(a*{i,1}, b*{i,1}), (b*{i,1}, b*{i,2}), \ldots, (b*{i,m}, a_{i,m+1})$.
    - Voor $x*i = \text{onwaar}$: Bogen $(c*{i,1}, d*{i,1}), (d*{i,1}, d*{i,2}), \ldots, (d*{i,m}, c_{i,m+1})$.
    - Verbindingen: $(c*{i,1}, a*{i,1}), (a*{i,m+1}, c*{i,m+1})$.
  - **Tussen variabelen**:
    - Voor $i = 1, \ldots, n-1$: Boog $(c*{i,m+1}, a*{i+1,1})$ om variabele-structuren te verbinden.
  - **Van en naar $s$ en $t$**:
    - Boog $(s, a_{1,1})$.
    - Boog $(c_{n,m+1}, t)$.
  - **Clause-verbindingen**:
    - Voor elke clause $c*j$, verbind $e_j$ met de vertices $b*{i,j}$ of $d_{i,j}$ afhankelijk van de literals in $c_j$:
      - Als $x*i \in c_j$, voeg bogen $(b*{i,j-1}, e*j), (e_j, b*{i,j})$ toe (of $(a*{i,1}, e_j), (e_j, b*{i,1})$ als $j = 1$).
      - Als $\neg x*i \in c_j$, voeg bogen $(d*{i,j-1}, e*j), (e_j, d*{i,j})$ toe (of $(c*{i,1}, e_j), (e_j, d*{i,1})$ als $j = 1$).
- **Polynomiale tijd**: De graaf heeft $O(nm)$ vertices ($2m+2$ per variabele, plus $m$ clause-vertices, plus $s, t$) en $O(nm)$ bogen. De constructie is polynomiaal in de grootte van $\phi$.

**Juistheidsbewijs (voorwaartse richting: als $\phi$ satisfiable is, dan $\langle G, s, t \rangle \in \text{HAMPATH}$)**:

- **Bewijs**:
  - Stel dat $\phi$ satisfiable is, met een waarheidstoewijzing $\nu: \{x_1, \ldots, x_n\} \to \{0, 1\}$ die elke clause waar maakt.
  - Construeer een Hamiltoniaans pad in $G$ van $s$ naar $t$:
    1. Start bij $s$, ga naar $a_{1,1}$.
    2. Voor elke variabele $x_i$ (i = 1, ..., n):
       - Als $\nu(x*i) = 1$, volg het "waar"-pad: $a*{i,1}, b*{i,1}, b*{i,2}, \ldots, b*{i,m}, a*{i,m+1}$.
       - Als $\nu(x*i) = 0$, volg het "onwaar"-pad: $a*{i,1}, c*{i,1}, d*{i,1}, d*{i,2}, \ldots, d*{i,m}, c*{i,m+1}, a*{i,m+1}$.
       - Ga van $a*{i,m+1}$ naar $c*{i,m+1}$, en dan naar $a_{i+1,1}$ (voor $i < n$).
    3. Voor elke clause $c_j$, bezoek vertex $e_j$:
       - Omdat $\nu$ $c_j$ waar maakt, is er minstens één literal in $c_j$ waar.
       - Als $x*i \in c_j$ en $\nu(x_i) = 1$, is het "waar"-pad gekozen, en bezoek $e_j$ via $(b*{i,j-1}, e*j, b*{i,j})$.
       - Als $\neg x*i \in c_j$ en $\nu(x_i) = 0$, is het "onwaar"-pad gekozen, en bezoek $e_j$ via $(d*{i,j-1}, e*j, d*{i,j})$.
       - Kies één waar literal per clause om $e_j$ te bezoeken (bij meerdere waar literals is de keuze willekeurig).
    4. Na het bezoeken van alle variabele-structuren, ga van $c_{n,m+1}$ naar $t$.
  - **Waarom is dit Hamiltoniaans**:
    - **Alle vertices bezocht**:
      - De variabele-structuren bezoeken alle $a*{i,j}, b*{i,j}, c*{i,j}, d*{i,j}$ (elke $b*{i,j}$ of $d*{i,j}$ wordt bezocht afhankelijk van $\nu(x_i)$).
      - Elke $e_j$ wordt precies één keer bezocht via een waar literal in $c_j$.
      - $s$ en $t$ worden bezocht aan het begin en einde.
    - **Geen herhaling**:
      - Het pad doorloopt elke variabele-structuur één keer, en de clause-vertices $e_j$ worden één keer bezocht.
      - De structuur van $G$ zorgt ervoor dat elke vertex slechts één inkomende en één uitgaande boog heeft in het pad, behalve waar clause-vertices worden bezocht.
    - **Geldig pad**:
      - Alle gebruikte bogen bestaan in $G$ (volgens de constructie).
  - **Conclusie**: Het pad is een Hamiltoniaans pad van $s$ naar $t$, dus $\langle G, s, t \rangle \in \text{HAMPATH}$.

**Opmerking**: De omgekeerde richting (als $\langle G, s, t \rangle \in \text{HAMPATH}$, dan is $\phi$ satisfiable) zou aantonen dat een Hamiltoniaans pad een consistente toewijzing $\nu$ induceert die $\phi$ waar maakt, maar we hebben de voorwaartse richting gekozen zoals gevraagd.

### (c) (1pt) Wat zou het betekenen als iemand kan aantonen dat HAMPATH in PTIME zit? Geef je argumentatie op een formele manier.

**Betekenis**:
Als iemand kan aantonen dat HAMPATH in PTIME zit, betekent dit dat er een deterministische Turingmachine bestaat die in polynomiale tijd kan beslissen of een gerichte graaf $G$ een Hamiltoniaans pad heeft van $s$ naar $t$. Formeel: HAMPATH $\in \text{PTIME}$, wat betekent dat er een algoritme is met tijdscomplexiteit $O(p(n))$, waarbij $p$ een polynomiale functie is en $n$ de grootte van de input is.

**Formele argumentatie**:

- **HAMPATH is NP-compleet**: HAMPATH is bewezen NP-compleet (zie cursusmateriaal, bijv. via reducties zoals 3SAT $\leq_p$ HAMPATH). Dit betekent:
  1. HAMPATH $\in \text{NP}$.
  2. HAMPATH is NP-hard: elk probleem $L \in \text{NP}$ is polynomiaal reduceerbaar naar HAMPATH ($L \leq_p \text{HAMPATH}$).
- **Gevolg van HAMPATH $\in \text{PTIME}$**:
  - Als HAMPATH in PTIME zit, dan kan elke instantie van HAMPATH in polynomiale tijd worden opgelost.
  - Omdat HAMPATH NP-compleet is, betekent dit dat voor elk probleem $L \in \text{NP}$, er een polynomiale reductie $f: L \to \text{HAMPATH}$ bestaat. Aangezien $f$ polynomiaal is en HAMPATH in polynomiale tijd oplosbaar is, kan $L$ ook in polynomiale tijd worden opgelost:
    - Tijd voor $L$: Bereken $f(x)$ (polynomiaal) + los HAMPATH op voor $f(x)$ (polynomiaal) = polynomiaal totaal.
  - Dus, elk probleem in NP is oplosbaar in polynomiale tijd, wat betekent dat $\text{NP} \subseteq \text{PTIME}$.
- **Conclusie**: Aangezien $\text{PTIME} \subseteq \text{NP}$ (elk probleem in PTIME is verifieerbaar in polynomiale tijd), volgt dat $\text{P} = \text{NP}$.
- **Implicaties**:
  - $\text{P} = \text{NP}$ zou een fundamentele doorbraak zijn in de complexiteitstheorie, omdat het betekent dat problemen zoals SAT, 3SAT, en SUBSETSUM (die nu exponentiële tijd vereisen in het slechtste geval) in polynomiale tijd oplosbaar zijn.
  - Dit zou verstrekkende gevolgen hebben voor cryptografie, optimalisatie, en vele andere domeinen, omdat veel beveiligingssystemen (zoals RSA) vertrouwen op de veronderstelling dat $\text{P} \neq \text{NP}$.

**Samenvattend**: Als HAMPATH in PTIME zit, volgt $\text{P} = \text{NP}$, wat een radicale verandering in onze kijk op computationele complexiteit zou betekenen.

## Vraag 3: PATH en PATH (8pt)

### (a) (1.5pt) Leg uit wat NLOGSPACE betekent. Uit je antwoord moet duidelijk zijn wat voor Turing machines gebruikt worden. Kortom, laat zien dat je de onderliggende definities kent.

### (b) (2.5pt) We hebben gezien dat $PATH = {〈G, s, t〉| er is een pad van s naar t in de gerichte graaf G}$ een probleem is in NLOGSPACE. Beschrijf het NLOGSPACE algoritme voor PATH in pseudo-code en analyseer dat het inderdaad een NLOGSPACE algoritme is.

### (c) (2.5pt) Beschouw de onderstaande gerichte graaf G. Zoals je ziet zijn er vier knopen bereikbaar vanuit s: s, u, v en w. De knoop t is niet bereikbaar. Wetende dat er vier knopen bereikbaar zijn vanuit s, leg uit hoe het algoritme dat PATH beslist in NLOGSPACE in het bewijs van de Stelling van Immerman-Szelepcsényi werkt op de onderstaande graaf. Je kan, bijvoorbeeld, twee “runs” van het algoritme geven: één die aanvaardt, en een andere die niet aanvaardt. Uit je antwoord moet duidelijk zijn dat je begrijpt hoe het algoritme werkt.

### (d) (1.5pt) Volgende op de vorige vraag, wat kan je afleiden uit $\overline{PATH} \in NLOGSPACE$? Geef je argumentatie op een formele manier.

## Vraag 4: PSPACE en NPSPACE (7pt)

### (a) (1.5pt) Formuleer de Stelling van Savitch. Wat heeft de Stelling van Savitch als gevolg voor de deterministische plaatscomplexiteit van PATH? Meer bepaald, volgt hieruit dat PATH ook in LOGSPACE zit?

### (b) (1pt) Om de Stelling van Savitch aan te tonen wordt de configuratiegraaf van een (s(n))-plaats niet-deterministische Turing machine M gebruikt. Schat de grootte van de configuratiegraaf af voor M op een input woord van lengte n. Geef je argumentatie. Waarom vraagt deze grootte om een meer ingenieuze manier om de Stelling van Savitch aan te tonen?

### (c) (3pt) Deze ingenieuze manier in het bewijs van de Stelling van Savitch zit omvat in het gebruik van de procedure ISBEREIKBAAR. Antwoord de volgende vragen:

- Vul de volgende pseudo-code verder aan:

```
ISBEREIKBAAR(c1, c2, t)

Als t = 1, check [vul aan]

Als t >1 dan [vul aan]

Voer ISBEREIKBAAR([vul aan])

Voer ISBEREIKBAAR([vul aan])

Als beiden aanvaarden, aanvaard. Als nog niet aanvaard, verwerp.

```

- Hoe wordt uiteindelijk ISBEREIKBAAR uitgevoerd in het bewijs van de Stelling

van Savitch? Maak duidelijk wat het onderliggende idee is.

- Hoeveel plaats heeft ISBEREIKBAAR nodig, wetende dat de input een (s(n))-

plaats niet-deterministische Turing machine is? Leg zo gedetailleerd mogelijk

uit.

### (d) (1.5pt) Is NP ⊆PSPACE of PSPACE ⊆NP? Wat kan je verder zeggen over de

tijdscomplexiteit van problemen in PSPACE? Leg uit.
