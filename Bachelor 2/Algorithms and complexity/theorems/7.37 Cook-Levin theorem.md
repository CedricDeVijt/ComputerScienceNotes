## PROOF IDEA

Showing that SAT is in NP is easy, and we do so shortly. The hard part of the proof is showing that any language in NP is polynomial time reducible to SAT.

To do so, we construct a polynomial time reduction for each language A in NP to SAT. The reduction for A takes a string w and produces a Boolean formula $\phi$ that simulates the NP machine for A on input w. If the machine accepts, $\phi$ has a satisfying assignment that corresponds to the accepting computation. If the machine doesn’t accept, no assignment satisfies $\phi$. Therefore, w is in A if and only if $\phi$ is satisfiable.
Actually constructing the reduction to work in this way is a conceptually simple task, though we must cope with many details. A Boolean formula may contain the Boolean operations AND, OR, and NOT, and these operations form the basis for the circuitry used in electronic computers. Hence the fact that we can design a Boolean formula to simulate a Turing machine isn’t surprising. The details are in the implementation of this idea.

## PROOF

First, we show that SAT is in NP. A nondeterministic polynomial time machine can guess an assignment to a given formula $\phi$ and accept if the assignment satisfies $\phi$.

Next, we take any language A in NP and show that A is polynomial time reducible to SAT. Let N be a nondeterministic Turing machine that decides A in $n^k$ time for some constant k. (For convenience, we actually assume that N runs in time $n^k-3$.) The following notion helps to describe the reduction.

### Tableau

A tableau for N on w is an $n^k \times n^k$ table whose rows are the configurations of a branch of the computation of N on input w, as shown in the following figure.

![[Bachelor 2/Algorithms and complexity/images/Pasted image 20250530190053.png]]

For convenience later, we assume that each configuration starts and ends with a # symbol. Therefore, the first and last columns of a tableau are all #s. The first row of the tableau is the starting configuration of N on w, and each row follows the previous one according to N’s transition function. A tableau is accepting if any row of the tableau is an accepting configuration. Every accepting tableau for N on w corresponds to an accepting computation branch of N on w. Thus, the problem of determining whether N accepts w is equivalent to the problem of determining whether an accepting tableau for N on w exists.

### Reduction

Now we get to the description of the polynomial time reduction f from A to SAT. On input w, the reduction produces a formula $\phi$. We begin by describing the variables of $\phi$. Say that $Q$ and $Γ$ are the state set and tape alphabet of N, respectively. Let $C= Q \cup Γ \cup {\#}$. For each i and j between 1 and $n^k$ and for each s in C, we have a variable, $x_{i,j,s}$.

Each of the $(n^k)^2$ entries of a tableau is called a cell. The cell in row i and column j is called cell\[i,j\] and contains a symbol from C. We represent the
contents of the cells with the variables of $\phi$. If $x_{i,j,s}$ takes on the value 1, it means that cell\[i,j\] contains an s.

Now we design $\phi$ so that a satisfying assignment to the variables does correspond to an accepting tableau for N on w. The formula $\phi$ is the AND of four parts: $$\phi_{cell} \land \phi_{start} \land \phi_{move} \land \phi_{accept}$$ We describe each part in turn.

#### Cel constraint

The first thing we must guarantee in order to obtain a correspondence between an assignment and a tableau is that the assignment turns on exactly one variable for each cell. Formula $\phi$ cell ensures this requirement by expressing it in terms of Boolean operations:

$$\phi_{cell} = \bigwedge_{1 \leq i,j \leq n^k} \left[ \left( \bigvee_{s \in C} x_{i,j,s} \right) \land \left( \bigwedge_{s,t \in C, s \neq t} (\overline{x_{i,j,s}} \lor \overline{x_{i,j,t}}) \right) \right]$$

where $C= {s_1,s_2,...,s_l}$. Hence $\phi$ cell is actually a large expression that contains a fragment for each cell in the tableau because i and j range from 1 to $n^k$.

The first part of each fragment says that at least one variable is turned on in the corresponding cell. The second part of each fragment says that no more than one variable is turned on (literally, it says that in each pair of variables, at least one is turned off) in the corresponding cell. These fragments are connected by $\land$ operations.

The first part of $\phi$ cell inside the brackets stipulates that at least one variable that is associated with each cell is on, whereas the second part stipulates that no more than one variable is on for each cell. Any assignment to the variables that satisfies $\phi$ (and therefore $\phi$ cell) must have exactly one variable on for every cell. Thus, any satisfying assignment specifies one symbol in each cell of the table.

#### Start constraint

Formula $\phi_{\text{start}}$ ensures that the first row of the table is the starting configuration of N on w by explicitly stipulating that the corresponding variables are on:

$$\phi_{start} = x_{1,1,s_1} \land x_{1,2,s_2} \land \dots \land x_{1,n^k,s_{n^k}}$$

where $s_j$ is the jth symbol of w. The first row of the tableau is thus completely specified by $\phi$ start.

#### Accept constraint

Formula $\phi_{accept}$ guarantees that an accepting configuration occurs in the tableau. It ensures that $q_{accept}$, the symbol for the accept state, appears in one of the cells of the tableau by stipulating that one of the corresponding variables is on:

$$\phi_{accept} = \bigvee_{1 \leq i,j \leq n^k} x_{i,j,q_{accept}}$$

This part of the formula ensures that at least one row of the tableau is an accepting configuration.

#### Move constraint

Formula $\phi$ move guarantees that each row of the tableau corresponds to a configuration that legally follows the preceding row’s configuration according to N’s rules. It does so by ensuring that each $2 \times 3$ window of cells is legal. We say that a $2 \times 3$ window is legal if that window does not violate the actions specified by N’s transition function. In other words, a window is legal if it might appear when one configuration correctly follows another. For example, say that a, b, and c are members of the tape alphabet, and q1 and q2 are states of N. Assume that when in state q1 with the head reading an a, N writes a b, stays in state q1, and moves right; and that when in state q1 with the head reading a b, N nondeterministically either

1. writes a c, enters q2, and moves to the left, or
2. writes an a, enters q2, and moves to the right.

Expressed formally, $δ(q_1,a) = {(q_1,b,R)}$ and $δ(q_1,b) = {(q_2,c,L),(q_,a,R)}$.

If the top row of the tableau is the start configuration and every window in the tableau is legal, each row of the tableau is a configuration that legally follows the preceding one.

We prove this claim by considering any two adjacent configurations in the tableau, called the upper configuration and the lower configuration. In the upper configuration, every cell that contains a tape symbol and isn’t adjacent to a state symbol is the center top cell in a window whose top row contains no states. Therefore, that symbol must appear unchanged in the center bottom of the window. Hence it appears in the same position in the bottom configuration.

The window containing the state symbol in the center top cell guarantees that the corresponding three positions are updated consistently with the transition function. Therefore, if the upper configuration is a legal configuration, so is the lower configuration, and the lower one follows the upper one according to N’s rules. Note that this proof, though straightforward, depends crucially on our choice of a 2 ×3 window size.

Now we return to the construction of $\phi_{move}$. It stipulates that all the windows in the tableau are legal. Each window contains six cells, which may be set in a fixed number of ways to yield a legal window. Formula $\phi$ move says that the settings of those six cells must be one of these ways, or

$$
\phi_{move} = \bigwedge_{1 \leq i < n^k,\ 1 < j < n^k}
\left[
\bigvee_{\substack{a_1, a_2, a_3, a_4, a_5, a_6}}
(x_{i,j-1,a_1} \land x_{i,j,a_2} \land x_{i,j+1,a_3}
\land x_{i+1,j-1,a_4} \land x_{i+1,j,a_5} \land x_{i+1,j+1,a_6})
\right]
$$

### Complexity of the Reduction

Next, we analyze the complexity of the reduction to show that it operates in polynomial time. To do so, we examine the size of $\phi$. First, we estimate the number of variables it has. Recall that the tableau is an $n^k \times n^k$ table, so it contains $n^{2k}$ cells. Each cell has l variables associated with it, where l is the number of symbols in C. Because l depends only on the TM N and not on the length of the input n, the total number of variables is $O(n^{2k})$.

We estimate the size of each of the parts of $\phi$. Formula $\phi_{cell}$ contains a fixed-size fragment of the formula for each cell of the tableau, so its size is $O(n^{2k} )$. Formula $\phi_{start}$ has a fragment for each cell in the top row, so its size is $O(n^k)$. Formulas $\phi_{move}$ and $\phi_{accept}$ each contain a fixed-size fragment of the formula for each cell of the tableau, so their size is $O(n^{2k})$. Thus, $\phi$ ’s total size is $O(n^{2k})$. That bound is sufficient for our purposes because it shows that the size of $\phi$ is polynomial in n. If it were more than polynomial, the reduction wouldn’t have any chance of generating it in polynomial time.

To see that we can generate the formula in polynomial time, observe its highly repetitive nature. Each component of the formula is composed of many nearly identical fragments, which differ only at the indices in a simple way. Therefore, we may easily construct a reduction that produces $\phi$ in polynomial time from the input w.

Thus, we have concluded the proof of the Cook–Levin theorem, showing that SAT is NP-complete.

$\blacksquare$
