## PROOF IDEA

The 2SAT problem is solved by constructing an implication graph G from a 2CNF formula ϕ, where each clause (l₁ ∨ l₂) is represented by implications ¬l₁ → l₂ and ¬l₂ → l₁. The formula is satisfiable if and only if no variable x and its negation ¬x belong to the same strongly connected component (SCC) in G, which can be checked by ensuring there is no path from x to ¬x and from ¬x to x for any variable x. This can be done in polynomial time.

## PROOF

We prove that 2SAT is in P by giving and analyzing an algorithm M, demonstrating its polynomial-time complexity, and proving its correctness (i.e., M accepts ⟨ϕ⟩ if and only if the 2CNF formula ϕ is satisfiable).

#### Polynomial Time Complexity

Let n be the number of variables in ϕ, and m the number of clauses (each with exactly two literals). The implication graph G has 2n nodes (x and ¬x for each variable x) and at most 2m edges (two per clause).

- **Step 1 (node creation)**: Create nodes x and ¬x for each variable. Time: O(n).
- **Step 2 (edge creation)**: For each clause (l₁ ∨ l₂), add directed edges (¬l₁, l₂) and (¬l₂, l₁). Since there are m clauses, this takes O(m) time.
- **Steps 3–5 (path checking)**: For each of the n variables x, check if there are paths from x to ¬x and from ¬x to x in G. Each reachability query uses BFS or DFS, which takes O(n + m) time. With 2n queries (two per variable), the total time is O(n(n + m)).

The input size is |⟨ϕ⟩| ≈ O(n + m log n) (accounting for variable indices). The total runtime is O(n(n + m)) = O(n² + nm), which is polynomial. (Note: This can be optimized to O(n + m) by computing all SCCs once using Tarjan’s or Kosaraju’s algorithm, but the given algorithm suffices for polynomial time.)

#### Correctness

We must show: ϕ is satisfiable ⇔ for every variable x, G does not have both a path from x to ¬x and from ¬x to x.

This condition is equivalent to: no variable x has x and ¬x in the same SCC of G (since u and v are in the same SCC if and only if there are paths u → v and v → u).

**Forward Direction (⇒): If ϕ is satisfiable, no x and ¬x are in the same SCC.**
Suppose ϕ is satisfiable under an assignment σ : {variables} → {true, false}. Assume for contradiction that some variable x has paths x → ¬x and ¬x → x in G.

- In the implication graph, a path a → b means that setting σ(a) = true implies σ(b) = true (since edges represent implications).
- A path x → ¬x implies σ(x) = true ⇒ σ(¬x) = true, i.e., σ(x) = true ⇒ σ(x) = false, a contradiction.
- Similarly, a path ¬x → x implies σ(¬x) = true ⇒ σ(x) = true, i.e., σ(x) = false ⇒ σ(x) = true, another contradiction.
  Since the paths are mutual, they force σ(x) = true and σ(x) = false simultaneously, contradicting the satisfiability of ϕ. Thus, no such mutual paths exist for any x.

**Reverse Direction (⇐): If no x and ¬x are in the same SCC, then ϕ is satisfiable.**
We construct a satisfying assignment σ:

- Compute the SCCs of G, partitioning the 2n nodes into components.
- Form the condensation graph Ĝ, where each SCC is a supernode, and edges exist between supernodes if there were edges between their nodes in G. Since SCCs capture all cycles, Ĝ is a directed acyclic graph (DAG).
- Assign truth values using a topological sort of Ĝ: Process supernodes in reverse topological order (sinks first). For each supernode:
  - If it contains ¬x and x has not been assigned, set σ(x) = false (forcing ¬x = true).
  - If it contains x and x has not been assigned, set σ(x) = true (forcing x = true).
- Since no SCC contains both x and ¬x (by assumption), assigning σ(x) does not conflict with ¬x. If an SCC containing x forces x = true, the absence of mutual paths ensures ¬x is not in a downstream component that would force ¬x = true (which would imply x = false).
  The assignment is consistent because:
- **Implications are respected**: If a → b in G (i.e., there is a path or edge), then σ(a) = true implies σ(b) = true, as a’s SCC precedes or equals b’s in the topological order (and equals only if they are in the same SCC, which cannot mix x and ¬x).
- **No contradictions**: Assigning σ(x) = false when ¬x’s component is “higher” avoids conflicts, as the DAG structure of Ĝ prevents cyclic implications.
  The assignment satisfies all clauses: For each clause (l₁ ∨ l₂), the edges ¬l₁ → l₂ and ¬l₂ → l₁ ensure that if σ(l₁) = false and σ(l₂) = false, then σ(¬l₁) = true and σ(¬l₂) = true, which would imply paths forcing a contradiction (e.g., ¬l₁ → l₂ → ¬l₁ if l₂ and ¬l₂ are connected). However, the absence of x ↔ ¬x paths ensures no such contradiction arises, so at least one of l₁ or l₂ is true.

Thus, M correctly decides 2SAT, and since it runs in polynomial time, 2SAT ∈ P.
