
Any nondeterministic Turing machine (NTM) that uses $f(n)$ space can be converted to a deterministic Turing machine (DTM) that uses $O(f^2(n))$ space.

For any function $f: N \rightarrow R^+\text{, where }f(n) \geq n$, $NSPACE(f(n)) \subseteq SPACE(f^2(n))$.

## Proof idea

We are given two configurations of the NTM, $c_1$ and $c_2$, together with a number $t$, and we test whether the NTM can get from $c_1$ to $c_2$ within $t$ steps using only $f(n)$ space. We call this problem the yieldability problem. By solving the yieldability problem, where $c_1$ is the start configuration, $c_2$ is the accept configuration, and $t$ is the maximum number of steps that the nondeterministic machine can use, we can determine whether the machine accepts its input.

We give a deterministic, recursive algorithm that solves the yieldability problem. It operates by searching for an intermediate configuration $c_m$, and recursively testing whether

1. $c_1$ can get to $c_m$ within $t/2$ steps
2. whether $c_m$ can get to $c_2$ within t/2 steps.

Reusing the space for each of the two recursive tests allows a significant savings of space.

This algorithm needs space for storing the recursion stack. Each level of the recursion uses $O(f(n))$ space to store a configuration. The depth of the recursion is $\log t$, where $t$ is the maximum time that the nondeterministic machine may use on any branch. We have $t = 2^{O(f(n))}$, so $\log t= O(f(n))$. Hence the deterministic simulation uses $O(f^2(n))$ space.

## Proof

Let $N$ be an NTM deciding a language $A$ in space $f(n)$. We construct a deterministic TM $M$ deciding $A$. Machine $M$ uses the procedure `CANYIELD`, which tests whether one of $N$â€™s configurations can yield another within a specified number of steps. This procedure solves the yieldability problem described in the proof idea.

Let $w$ be a string considered as input to $N$. For configurations $c_1$ and $c_2$ of $N$, and integer $t$, `CANYIELD(c1,c2,t)` outputs accept if $N$ can go from configuration $c_1$ to configuration $c_2$ in $t$ or fewer steps along some nondeterministic path. If not, `CANYIELD` outputs reject. For convenience, we assume that $t$ is a power of 2.

```python
def canyield(c1:configuration, c2:configuration, t:int) -> bool:
    # Base case: check if c1 can yield c2 in one step
    if t == 1:
        return c1 == c2 or can_transition(c1, c2):

    # Recursive case: try to find an intermediate configuration
    for cm in get_all_configurations():
        if canyield(c1, cm, t/2) and canyield(cm, c2, t/2):
            return True

    return False
```

Now we define $M$ to simulate $N$ as follows. We first modify $N$ so that when it accepts, it clears its tape and moves the head to the leftmost cell, thereby entering a configuration called $c_{\text{accept}}$. We let $c_{\text{start}}$ be the start configuration of $N$ on $w$. We select a constant $d$ so that $N$ has no more than $2^{df (n)}$ configurations using $f(n)$ tape, where $n$ is the length of $w$. Then we know that $2^{df (n)}$ provides an upper bound on the running time of any branch of $N$ on $w$.

Algorithm `CANYIELD` obviously solves the yieldability problem, and hence $M$ correctly simulates $N$. We need to analyze it to verify that $M$ works within $O(f^2(n))$ space.

Whenever `CANYIELD` invokes itself recursively, it stores the current stage number and the values of $c_1$, $c_2$, and $t$ on a stack so that these values may be restored upon return from the recursive invocation. Each level of the recursion thus uses $O(f(n))$ additional space. Furthermore, each level of the recursion divides the size of $t$ in half. Initially $t$ starts out equal to $2^{df (n)}$, so the depth of the recursion is $O(\log 2^{df (n)})$ or $O(f(n))$. Therefore, the total space used is $O(f^2(n))$, as claimed.

One technical difficulty arises in this argument because algorithm $M$ needs to know the value of $f(n)$ when it calls `CANYIELD`. We can handle this difficulty by modifying $M$ so that it tries $f(n) = 1,2,3, \dots$ For each value $f(n) = i$, the modified algorithm uses `CANYIELD` to determine whether the accept configuration is reachable. In addition, it uses `CANYIELD` to determine whether $N$ uses at least space $i+ 1$ by testing whether $N$ can reach any of the configurations of length $i+1$ from the start configuration. If the accept configuration is reachable, $M$ accepts; if no configuration of length $i+ 1$ is reachable, $M$ rejects; and otherwise, $M$ continues with $f(n) = i+ 1$.

$\blacksquare$
