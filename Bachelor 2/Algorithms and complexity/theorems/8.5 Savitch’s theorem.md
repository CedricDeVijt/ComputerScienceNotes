# Theorem: NTM to DTM Space Conversion

Any nondeterministic Turing machine (NTM) that uses $f(n)$ space can be converted to a deterministic Turing machine (DTM) that uses $O(f^2(n))$ space.

For any function $f: N \rightarrow R^+, where f(n) \geq n$, $NSPACE(f(n)) \subseteq SPACE(f^2(n))$.

## Proof idea

We are given two configurations of the NTM, $c_1$ and $c_2$, together with a number $t$, and we test whether the NTM can get from $c_1$ to $c_2$ within $t$ steps using only $f(n)$ space. We call this problem the yieldability problem. By solving the yieldability problem, where $c_1$ is the start configuration, $c_2$ is the accept configuration, and $t$ is the maximum number of steps that the nondeterministic machine can use, we can determine whether the machine accepts its input. We give a deterministic, recursive algorithm that solves the yieldability problem. It operates by searching for an intermediate configuration cm, and recursively testing whether (1) $c_1$ can get to $c_m$ within $t/2$ steps, and (2) whether $c_m$ can get to $c_2$ within t/2 steps. Reusing the space for each of the two recursive tests allows a significant savings of space. This algorithm needs space for storing the recursion stack. Each level of the recursion uses $O(f(n))$ space to store a configuration. The depth of the recursion is $\log t$, where $t$ is the maximum time that the nondeterministic machine may use on any branch. We have $t = 2^{O(f(n))}$, so $\log t= O(f(n))$. Hence the deterministic simulation uses $O(f^2(n))$ space.

## Proof

Let $N$ be an NTM deciding a language $A$ in space $f(n)$. We construct a deterministic TM $M$ deciding $A$. Machine $M$ uses the procedure CANYIELD, which tests whether one of $N$â€™s configurations can yield another within a specified number of steps. This procedure solves the yieldability problem described in the proof idea. Let w be a string considered as input to N. For configurations c1 and c2 of N, and integer t, CANYIELD(c1,c2,t) outputs accept if N can go from configuration c1 to configuration c2 in t or fewer steps along some nondeterministic path. If not, CANYIELD outputs reject. For convenience, we assume that tis a power of 2.

```python
def canyield(c1:configuration, c2:configuration, t:int) -> bool:
    if t == 1:
        # Base case: check if c1 can yield c2 in one step
        if c1 == c2 or can_transition(c1, c2):
            return True
        else:
            return False

    # Recursive case: try to find an intermediate configuration
    for cm in get_all_configurations():
        if (canyield(c1, cm, t/2) == True and
            canyield(cm, c2, t/2) == True):
            return True

    return False
```

$\blacksquare$
