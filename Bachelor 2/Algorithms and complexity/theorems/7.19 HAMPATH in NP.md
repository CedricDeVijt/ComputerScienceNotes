## PROOF

The following is a nondeterministic Turing machine (NTM) that decides the HAMPATH problem in nondeterministic polynomial time. We defined the time of a nondeterministic machine to be the time used by the longest computation branch.

$N_1 =$
“On input $⟨G,s,t⟩$, where $G$ is a directed graph with nodes $s$ and $t$:

1. Write a list of $m$ numbers, $p_1,\dots ,p_m$, where $m$ is the number of nodes in $G$. Each number in the list is nondeterministically selected to be between $1$ and $m$.
2. Check for repetitions in the list. If any are found, reject.
3. Check whether $s= p_1$ and $t= p_m$. If either fail, reject.
4. For each $i$ between $1$ and $m−1$, check whether $(p_i,p_{i+1})$ is an edge of $G$. If any are not, reject. Otherwise, all tests have been passed, so accept.”

To analyze this algorithm and verify that it runs in nondeterministic polynomial time, we examine each of its stages. In stage 1, the nondeterministic selection clearly runs in polynomial time. In stages 2 and 3, each part is a simple check, so together they run in polynomial time. Finally, stage 4 also clearly runs in polynomial time. Thus, this algorithm runs in nondeterministic polynomial time.

```py
def verify_hampath(graph, certificate, start_node, end_node) -> bool:
    # Get the number of nodes in the graph
    m = len(graph.nodes)

    # Check 1: Certificate must contain exactly m nodes (visit each node exactly once)
    if len(certificate) != m:
        return False

    # Check 2: Path must start at the specified start node and end at the specified end node
    if certificate[0] != start_node or certificate[m-1] != end_node:
        return False

    # Check 3: Verify that each node appears exactly once (no repetitions)
    visited: Set[int] = set()
    for i in range(m):
        if certificate[i] in visited:
            # Duplicate node found - reject
            return False
        visited.add(certificate[i])

        # Check 4: Verify that consecutive nodes in the certificate are connected by edges
        if i < m - 1:
            if not is_edge(graph, certificate[i], certificate[i + 1]):
                # Missing edge between consecutive nodes - reject
                return False

    # All checks passed - this is a valid Hamiltonian path
    return True
```
