\section{LR Items}

An $\mathbf{LR(k) \text{ item}}$ is a production with a dot ($\bullet$) marking a position in the right-hand side, along with a $k$-symbol lookahead string. The dot indicates how much of the production has been recognized so far. An item $[A \to \alpha \bullet \beta, w]$ means we have seen $\alpha$ and expect to see $\beta$, with lookahead $w$.

\textbf{Types of LR Items:}
\begin{itemize}
\item \textbf{Shift item}: $[A \to \alpha \bullet a \beta, w]$ where $a$ is a terminal
\item \textbf{Reduce item}: $[A \to \alpha \bullet, w]$ where the dot is at the end
\item \textbf{Goto item}: $[A \to \alpha \bullet B \beta, w]$ where $B$ is a non-terminal
\end{itemize}

\textbf{Steps to Compute} $\mathbf{CLOSURE(I)}$ for a set of items $I$:
\begin{enumerate}
\item Initialize $CLOSURE(I) = I$.
\item For each item $[A \to \alpha \bullet B \beta, w]$ in $CLOSURE(I)$ where $B$ is a non-terminal:
   \begin{itemize}
   \item For each production $B \to \gamma$:
     \begin{itemize}
     \item Compute $FIRST^k(\beta w)$ (concatenate $\beta$ and lookahead $w$, then take first $k$ symbols).
     \item For each string $u \in FIRST^k(\beta w)$:
       \begin{itemize}
       \item Add item $[B \to \bullet \gamma, u]$ to $CLOSURE(I)$ if not already present.
       \end{itemize}
     \end{itemize}
   \end{itemize}
\item Repeat step 2 until no new items are added to $CLOSURE(I)$.
\end{enumerate}

\textbf{Steps to Compute} $\mathbf{GOTO(I, X)}$ for item set $I$ and symbol $X$:
\begin{enumerate}
\item Initialize $J = \emptyset$.
\item For each item $[A \to \alpha \bullet X \beta, w]$ in $I$:
   \begin{itemize}
   \item Add item $[A \to \alpha X \bullet \beta, w]$ to $J$.
   \end{itemize}
\item Return $CLOSURE(J)$.
\end{enumerate}

\textbf{Steps to Construct the} $\mathbf{LR(k) \text{ Automaton}}$:
\begin{enumerate}
\item \textbf{Augment the Grammar}: Add a new start symbol $S'$ and production $S' \to S \$^k$, where $S$ is the original start symbol and $\$^k$ is the $k$-symbol end-of-input marker.
\item \textbf{Initialize the First State}: Compute the initial state $I_0 = CLOSURE(\{[S' \to \bullet S \$^k]\})$, where the dot ($\bullet$) indicates the current position in the production.
\item \textbf{Compute CLOSURE}: For a set of items $I$:
   \begin{itemize}
   \item Start with $CLOSURE(I) = I$.
   \item For each item $[A \to \alpha \bullet B \beta, w]$ in $CLOSURE(I)$, where $B$ is a nonterminal:
     \begin{itemize}
     \item For each production $B \to \gamma$, compute $FIRST^k(\beta w)$.
     \item For each $u \in FIRST^k(\beta w)$, add $[B \to \bullet \gamma, u]$ to $CLOSURE(I)$ if not present.
     \end{itemize}
   \item Repeat until no new items are added.
   \end{itemize}
\item \textbf{Compute GOTO}: For a state $I$ and symbol $X$ (terminal or nonterminal):
   \begin{itemize}
   \item Initialize $J = \emptyset$.
   \item For each item $[A \to \alpha \bullet X \beta, w]$ in $I$, add $[A \to \alpha X \bullet \beta, w]$ to $J$.
   \item Return $CLOSURE(J)$.
   \end{itemize}
\item \textbf{Build the State Machine}:
   \begin{itemize}
   \item Initialize the set of states $\mathcal{C} = \{I_0\}$ and worklist $W = \{I_0\}$.
   \item While $W \neq \emptyset$:
     \begin{itemize}
     \item Remove a state $I$ from $W$.
     \item For each symbol $X$ where $GOTO(I, X) \neq \emptyset$:
       \begin{itemize}
       \item Let $J = GOTO(I, X)$.
       \item If $J \notin \mathcal{C}$, add $J$ to $\mathcal{C}$ and $W$.
       \item Add transition $I \xrightarrow{X} J$ to the automaton.
       \end{itemize}
     \end{itemize}
   \end{itemize}
\item \textbf{Construct the Parsing Table}:
   \begin{itemize}
   \item For each state $I \in \mathcal{C}$:
     \begin{itemize}
     \item If $[A \to \alpha \bullet a \beta, w] \in I$ and $GOTO(I, a) = J$, add shift action to state $J$ for terminal $a$.
     \item If $[A \to \alpha \bullet, w] \in I$, add reduce action by $A \to \alpha$ for lookahead $w$.
     \item If $[S' \to S \bullet \$^k] \in I$, add accept action for $\$^k$.
     \end{itemize}
   \item Check for conflicts: Shift-reduce or reduce-reduce conflicts indicate the grammar is not LR(k).
   \end{itemize}
\end{enumerate}

\section{Parsing Conflicts}

\textbf{Shift-Reduce Conflict}

A shift-reduce conflict occurs when the parser cannot decide whether to:
\begin{enumerate}
\item \textbf{Shift}: Move the next input symbol onto the stack
\item \textbf{Reduce}: Apply a production rule to reduce symbols on the stack
\end{enumerate}

In terms of LR items, this happens when a state contains both:
\begin{enumerate}
\item A shift item: $[A \to \alpha \bullet a \beta, w]$ (expecting terminal $a$)
\item A reduce item: $[B \to \gamma \bullet, a]$ (ready to reduce with lookahead $a$)
\end{enumerate}

The conflict manifests in the parsing table as both a shift action and a reduce action for entry $[state, a]$.


\textbf{Reduce-Reduce Conflict}

A reduce-reduce conflict occurs when the parser cannot decide which production to use for reduction. This happens when a state contains multiple reduce items with overlapping lookaheads:
\begin{enumerate}
\item $[A \to \alpha \bullet, w]$
\item $[B \to \beta \bullet, w]$
\end{enumerate}

Both items indicate that reduction is possible with the same lookahead $w$, but the parser cannot determine which production rule to apply.

The conflict manifests in the parsing table as multiple reduce actions for the same entry $[state, w]$.


\textbf{Resolution}

These conflicts indicate that the grammar is not in the respective LR class (LR(k), LALR(k), or SLR(k)). Resolution strategies include:
\begin{enumerate}
\item Increasing the lookahead length $k$
\item Grammar transformation (left-factoring, eliminating ambiguity)
\item Using precedence and associativity rules
\end{enumerate}
