% DONE

\section{Grammar Proofs}

Note: if a language described by a grammar is asked, the grammar can be altered. The given grammar might be alterd to achieve a certain parser type, but the language remains the same.

\subsection{Preliminary Checks}

Before testing for specific parser types, perform these essential checks:

\begin{enumerate}
    \item \textbf{Well-formed grammar verification}
    \begin{itemize}
        \item Ensure the CFG has no useless symbols (nonterminals that cannot derive any terminal string or cannot be reached from the start symbol).
        \item Remove useless symbols using standard algorithms (identify productive and reachable symbols).
    \end{itemize}

    \item \textbf{Ambiguity check}
    \begin{itemize}
        \item An ambiguous grammar cannot be guaranteed to be LL(k), SLR(k), LALR(k), or LR(k) for any $k$, as ambiguity may lead to parsing conflicts.
        \item Test by attempting to construct multiple leftmost or rightmost derivations for the same string.
        \item If ambiguous, the grammar may require modification to be used with deterministic parsers.
    \end{itemize}

    \item \textbf{Left recursion elimination}
    \begin{itemize}
        \item For LL(k): Grammar must be free of left recursion (direct or indirect).
        \item Apply left recursion elimination techniques if needed.
        \item For LR-based parsers (SLR, LALR, LR): Left recursion is generally acceptable and does not require elimination.
    \end{itemize}
\end{enumerate}

\subsection{LL(k) Parser Check}

\textbf{Definition:} An LL(k) grammar can be parsed top-down by a deterministic pushdown automaton using $k$ lookahead symbols, ensuring a unique production choice for each nonterminal and lookahead, without backtracking.

\subsubsection{Algorithm Steps}

\begin{enumerate}
    \item \textbf{Compute $\text{FIRST}_k$ sets}

    \item \textbf{Compute $\text{FOLLOW}_k$ sets}

    \item \textbf{Construct LL(k) parsing table}
    \begin{itemize}
        \item For each production $A \to \alpha$, compute the lookahead set:
        \begin{itemize}
            \item If $\alpha$ derives a string $w$ of length $\geq k$, include $\text{FIRST}_k(w)$.
            \item If $\alpha$ derives a string shorter than $k$ (including $\epsilon$), include prefixes of $\text{FIRST}_k(\alpha) \cdot \text{FOLLOW}_k(A)$ of length $k$.
        \end{itemize}
        \item Place the production in table cell $[A, t]$ for each terminal string $t$ in the lookahead set.
    \end{itemize}

    \item \textbf{Check for conflicts}
    \begin{itemize}
        \item The grammar is LL(k) if no table cell $[A, t]$ contains multiple productions, ensuring deterministic parsing.
    \end{itemize}
\end{enumerate}


\subsection{LR(k) Parser Check}

\textbf{Definition:} A grammar is LR(k) if a bottom-up parser can deterministically construct a rightmost derivation in reverse using a parsing table, $k$ lookahead symbols, and canonical LR(k) item sets.

\subsubsection{Algorithm Steps}

\begin{enumerate}
    \item \textbf{Construct LR(k) item sets}

    \item \textbf{Build parsing table}

    \item \textbf{Check for conflicts}
    \begin{itemize}
        \item Grammar is LR(k) if each table entry has at most one action.
        \item Shift-reduce conflict: same entry has shift and reduce.
        \item Reduce-reduce conflict: same entry has multiple reduces.
    \end{itemize}
\end{enumerate}


\subsection{SLR(k) Parser Check}

\textbf{Definition:} SLR(k) (Simple LR(k)) is a bottom-up parsing technique that simplifies LR(k) by using $\text{FOLLOW}_k(A)$ sets to approximate k-token lookaheads for reduce actions. It is less powerful than LR(k) but easier to compute.

\subsubsection{Algorithm Steps}

\begin{enumerate}
    \item \textbf{Build LR(0) DFA}
    \begin{itemize}
        \item Construct the DFA where states are sets of LR(0) items (productions with a dot) and transitions represent shifts on terminals or nonterminals.
    \end{itemize}

    \item \textbf{Compute FOLLOW$_k$ sets}

    \item \textbf{Construct SLR(k) parsing table}
    \begin{itemize}
        \item Add shift and goto actions from the LR(0) DFA.
        \item For each state $I$ with a completed item $[A \to \alpha \cdot]$, add a reduce action by $A \to \alpha$ for each $t \in \text{FOLLOW}_k(A)$.
        \item Check for conflicts (shift-reduce or reduce-reduce). If none exist, the grammar is SLR(k).
    \end{itemize}

    \item \textbf{Parse input}
    \begin{itemize}
        \item Use the parsing table with a stack-based algorithm to process input strings, applying shift, reduce, or goto actions based on the current state and lookahead tokens.
    \end{itemize}
\end{enumerate}

\subsection{LALR(k) Parser Check}

\textbf{Definition:} LALR(k) (Look-Ahead LR) is a parsing technique that reduces the size of an LR(k) parser by merging states with the same core (items without lookaheads) while retaining k-symbol lookaheads. LALR(1) is most commonly used due to its efficiency.

\subsubsection{Algorithm Steps}

\begin{enumerate}
    \item \textbf{Construct LR(0) DFA}

    \item \textbf{Compute LALR(k) Lookaheads}
    \begin{itemize}
        \item For each LR(0) item $[A \to \alpha \cdot \beta]$ in a state, compute the set of terminal strings of length up to $k$ (lookaheads) that can follow $\beta$.
        \item Propagate lookaheads through the DFA by tracing paths from states where $\beta$ leads to a terminal or the endmarker.
        \item Merge lookaheads for items in states with the same core (same LR(0) items) to form LALR(k) states.
    \end{itemize}

    \item \textbf{Construct LALR(k) Parsing Table}
    \begin{itemize}
        \item Use the LR(0) DFA for shift and goto actions: for state $s$ and symbol $X$, transition to state $s'$ implies action shift (if $X$ is a terminal) or goto $s'$ (if $X$ is a nonterminal).
        \item For each item $[A \to \alpha \cdot, w]$ in a state, where $w$ is a lookahead string of length up to $k$, add a reduce action by production $A \to \alpha$ on lookahead $w$.
    \end{itemize}

    \item \textbf{Check for Conflicts}
    \begin{itemize}
        \item Verify the parsing table has no shift-reduce or reduce-reduce conflicts.
        \item The grammar is LALR(k) if no conflicts exist. If conflicts occur, modify the grammar or use precedence rules to resolve them.
    \end{itemize}
\end{enumerate}


\subsection{Parser Type Relationships and Optimization}

\begin{itemize}
    \item LR($k$) $\supseteq$ LALR($k$) $\supseteq$ SLR($k$)
    \item LL($k$) $\subsetneq$ LR($k$)  for all $k \geq 0$
    \item LR(0) $\subsetneq$ SLR(1) $\subsetneq$ LALR(1) $\subsetneq$ LR(1) $\subsetneq$ LR(2) $\subsetneq \cdots \subsetneq$ LR($k$) $\subsetneq$ LR($k + 1$) $\subsetneq \cdots$
\end{itemize}
