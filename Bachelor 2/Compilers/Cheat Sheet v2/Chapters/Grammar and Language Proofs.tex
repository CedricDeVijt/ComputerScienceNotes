% DONE

\section{Grammar Proofs}

% Explaining the note about grammar alteration
Note: If a language described by a grammar is specified, the grammar can be altered to achieve a certain parser type while preserving the language generated.

\subsection{Preliminary Checks}

% Performing essential checks before parser-specific tests
Before testing for specific parser types, perform these essential checks:

\begin{enumerate}
    \item \textbf{Well-formed grammar verification}
    \begin{itemize}
        \item Ensure the CFG has no useless symbols (nonterminals that cannot derive any terminal string or cannot be reached from the start symbol).
        \item Remove useless symbols:
        \begin{enumerate}
            \item Identify \emph{productive} symbols (those deriving a terminal string).
            \item Identify \emph{reachable} symbols (those derivable from the start symbol).
            \item Eliminate all other symbols.
        \end{enumerate}
        \item Verify the grammar has at least one terminal production and the start symbol is productive and reachable.
    \end{itemize}

    \item \textbf{Ambiguity check}
    \begin{itemize}
        \item An ambiguous grammar cannot be LL(k) for any \( k \), as LL(k) requires deterministic parsing.
        \item LR(k), SLR(k), and LALR(k) can handle some ambiguous grammars if the parsing table is conflict-free.
        \item Testing for ambiguity is undecidable in general; heuristically, attempt to construct multiple leftmost (for LL(k)) or rightmost (for LR-based) derivations for the same string, or rely on parsing table conflicts.
    \end{itemize}

    \item \textbf{Left recursion elimination}
    \begin{itemize}
        \item For LL(k): Grammar must be free of direct or indirect left recursion to avoid infinite recursion in top-down parsing.
        \item Apply left recursion elimination (introducing new nonterminals to replace left-recursive productions) while preserving the language.
        \item Detect indirect left recursion by computing the transitive closure of the ``derives'' relation.
        \item For LR-based parsers (SLR, LALR, LR): Left recursion is acceptable.
    \end{itemize}
\end{enumerate}

\subsection{LL(k) Parser Check}

% Defining LL(k) and outlining the algorithm
\textbf{Definition:} A grammar is LL(k) if it can be parsed top-down with \( k \)-lookahead symbols without backtracking, using a deterministic parsing table.

\subsubsection{Algorithm Steps}

\begin{enumerate}
    \item \textbf{Compute \(\text{FIRST}_k\) and \(\text{FOLLOW}_k\) sets}
    \begin{itemize}
        \item See the dedicated section on First and Follow Sets for detailed computation steps.
    \end{itemize}

    \item \textbf{Construct LL(k) parsing table}
    \begin{itemize}
        \item For each production \( A \to \alpha \), compute lookahead set:
        \[
        \text{Lookahead}(A \to \alpha) = \text{FIRST}_k(\alpha) \cup (\text{FOLLOW}_k(A) \text{ if } \alpha \text{ is nullable}).
        \]
        \item Place production in table at \( [A, t] \) for each terminal string \( t \) in the lookahead set.
    \end{itemize}

    \item \textbf{Check for conflicts}
    \begin{itemize}
        \item Grammar is LL(k) if no cell \( [A, t] \) contains multiple productions.
        \item If conflicts arise, consider left factoring, increasing \( k \), or rewriting the grammar.
    \end{itemize}
\end{enumerate}

\subsection{LR(k) Parser Check}

% Defining LR(k) and outlining the algorithm
\textbf{Definition:} A grammar is LR(k) if it can be parsed bottom-up with \( k \)-lookahead symbols using a deterministic LR parsing table based on canonical LR(k) items.

\subsubsection{Algorithm Steps}

\begin{enumerate}
    \item \textbf{Construct LR(k) item sets}
    \begin{itemize}
        \item Augment grammar with \( S' \to S \).
        \item See the LR Items section for detailed item formats and CLOSURE/GOTO operations.
        \item Build canonical LR(k) DFA using closure and goto functions.
    \end{itemize}

    \item \textbf{Build parsing table}
    \begin{itemize}
        \item \textbf{Shift:} If \( [A \to \alpha \cdot a \beta, w] \) and \(\text{goto}(I, a) = J\), add shift to state \( J \).
        \item \textbf{Reduce:} If \( [A \to \alpha \cdot, w] \), add reduce by \( A \to \alpha \) for lookahead \( w \).
        \item \textbf{Accept:} If \( [S' \to S \cdot, \epsilon] \), accept on end-of-input.
        \item Empty cells indicate error actions.
    \end{itemize}

    \item \textbf{Check for conflicts}
    \begin{itemize}
        \item Grammar is LR(k) if no shift-reduce or reduce-reduce conflicts exist.
        \item If conflicts occur, test higher \( k \) or check for inherent ambiguity.
    \end{itemize}

    \item \textbf{Test incrementally}
    \begin{itemize}
        \item Start with \( k = 0 \) (LR(0) uses empty lookaheads \( w = \epsilon \)).
        \item Increase \( k \) if needed, noting exponential growth in table size.
    \end{itemize}
\end{enumerate}

\subsection{SLR(k) Parser Check}

% Defining SLR(k) and outlining the algorithm
\textbf{Definition:} SLR(k) is a simplified LR(k) using \(\text{FOLLOW}_k\) sets for lookaheads instead of precise LR(k) lookaheads, making it less powerful but easier to compute.

\subsubsection{Algorithm Steps}

\begin{enumerate}
    \item \textbf{Build LR(0) DFA}
    \begin{itemize}
        \item See LR Items section for DFA construction using LR(0) items.
    \end{itemize}

    \item \textbf{Compute \(\text{FOLLOW}_k\) sets}
    \begin{itemize}
        \item See the dedicated section on First and Follow Sets for computation steps.
    \end{itemize}

    \item \textbf{Construct SLR(k) parsing table}
    \begin{itemize}
        \item Shift and goto actions same as LR(0).
        \item For item \( [A \to \alpha \cdot] \) in state \( I \), add reduce by \( A \to \alpha \) for each \( t \in \text{FOLLOW}_k(A) \).
        \item Note: \(\text{FOLLOW}_k\) may introduce conflicts not present in LR(k).
    \end{itemize}

    \item \textbf{Check for conflicts and test incrementally}
    \begin{itemize}
        \item Grammar is SLR(k) if table has no conflicts.
        \item If conflicts arise, consider LALR(k) or LR(k).
    \end{itemize}
\end{enumerate}

\subsection{LALR(k) Parser Check}

% Defining LALR(k) and outlining the algorithm
\textbf{Definition:} LALR(k) is a compromise between SLR(k) and LR(k), using LR(0) DFA but with lookaheads computed by merging LR(k) states.

\subsubsection{Algorithm Steps}

\begin{enumerate}
    \item \textbf{Build LR(0) DFA}
    \begin{itemize}
        \item See LR Items section for DFA construction.
    \end{itemize}

    \item \textbf{Compute LALR(k) lookaheads}
    \begin{itemize}
        \item Use spontaneous generation and propagation of lookaheads through the LR(0) DFA.
        \item Merge lookaheads for items in the same LR(0) state.
    \end{itemize}

    \item \textbf{Construct LALR(k) parsing table}
    \begin{itemize}
        \item Shift and goto actions identical to LR(0).
        \item For item \( [A \to \alpha \cdot, w] \), add reduce by \( A \to \alpha \) for lookahead \( w \).
    \end{itemize}

    \item \textbf{Check for conflicts and test incrementally}
    \begin{itemize}
        \item Grammar is LALR(k) if table has no conflicts.
        \item If conflicts arise, test LR(k).
    \end{itemize}
\end{enumerate}

\subsection{Parser Type Relationships and Optimization}

% Correcting the hierarchy and clarifying relationships
\begin{itemize}
    \item \(\text{LR}(k) \supseteq \text{LALR}(k) \supseteq \text{SLR}(k)\).
    \item \(\text{LL}(k) \not\subseteq \text{LR}(k)\) and \(\text{LR}(k) \not\subseteq \text{LL}(k)\).
    \item If a grammar is not SLR(k), it may still be LALR(k) or LR(k), as LALR(k) and LR(k) use more precise lookaheads.
    \item If a grammar is LALR(k), it is also LR(k); if it is SLR(k), it is also LALR(k) and LR(k).
\end{itemize}

