For the questions below, we will focus on the language of (simplified) JSON documents. A JSON
document is a value. In turn, a value can be one of the following:

- an object,
- an array,
- a string (made up of alphabetic symbols only),
- a (possibly negative) integer number,
- a constant from true, false, or null.
  Then, an object is a curly-brace surrounded, comma-separated sequence of pairs k : v where k is a key
  (string) and v is a value. An array is a comma-separated sequence of values surrounded by square braces.

## 1. (5 points) Is the language of JSON documents a regular language? Why or why not?

No. The language of JSON documents is not regular because it requires handling nested structures (e.g., objects within objects, arrays within arrays). Regular languages cannot express nested patterns due to the absence of a stack mechanism. JSON’s recursive structure necessitates a context-free grammar (CFG).

## 2. (5 points) Write regular expressions for lexical units string, for number, and for all three constants.

- **String**: `[A-Za-z]+`
  _Simplified as alphabetic sequences without quotes._
  **DFA**: States transition on `a-z/A-Z`, accepting after at least one letter.

- **Number**: `-?[0-9]+`
  _Optional '-' followed by digits._
  **DFA**:

  - Start → `-` → State1 → `0-9` (loop, accepting).
  - Start → `0-9` → State2 (loop, accepting).

- **Constants**:
  - `true`, `false`, `null` (exact matches).
    **DFA for "true"**: Sequential states: `t → r → u → e` (accepting).

## 3. (5 points) How can we make sure the sequence “true” is always deemed a constant and not a string?

In lexical analysis, prioritize tokenizing constants (e.g., `true`, `false`, `null`) **before** strings. The lexer uses rule precedence: the first matching regex (in definition order) determines the token. By placing constants above the string regex, "true" is recognized as a constant.

## 4. (5 points) Give a context free grammar for the language of JSON documents.

```plaintext
Value   → Object | Array | STRING | NUMBER | CONSTANT
Object  → '{' PairList '}'
PairList → Pair | Pair ',' PairList | ε
Pair    → STRING ':' Value
Array   → '[' ElementList ']'
ElementList → Value | Value ',' ElementList | ε
```

## 5. (10 points) Compute First^2(Atom) and Follow^2(Prod) based on the following grammar.
```plaintext
(1) S → Exp$
(2) Exp → Prod Exp′
(3) Exp′ → +Prod Exp′
(4) Exp′→ −Prod Exp′
(5) Exp′→ ε
(6) Prod → Atom Prod′
(7) Prod′ → ∗Atom Prod′
(8) Prod′ → /Atom Prod′
(9) Prod′ → ε
(10) Atom → −Atom
(11) Atom → cst
(12) Atom → id
(13) Atom → (Exp)
```

### First^2(Atom)

