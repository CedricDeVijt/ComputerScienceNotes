% DONE

\section{Grammar Proofs}

\textbf{Preliminary Checks}
   1) Ensure the grammar is well-formed: The CFG should have no useless symbols (nonterminals that cannot derive any string or cannot be reached from the start symbol). Remove them using standard algorithms (e.g., find productive and reachable symbols).
   2) Check for ambiguity: An ambiguous grammar (one that allows multiple parse trees for the same string) cannot be LL(k), SLR(k), LALR(k), or LR(k) for any \( k \). Test for ambiguity by attempting to construct multiple leftmost or rightmost derivations for a string. If ambiguous, the grammar fails for all these parser types.
   3) Eliminate left recursion: For LL(k), the grammar must be free of left recursion (direct or indirect). Use left recursion elimination techniques if needed. For LR-based parsers (SLR, LALR, LR), left recursion is not an issue.

\textbf{Check for LL(k)}
   A grammar is LL(k) if it can be parsed top-down with \( k \) lookahead symbols without backtracking, using a deterministic parsing table.
   Steps:
     1. Compute $\text{FIRST}_k$ sets: For each nonterminal \( A \), compute the set of all possible strings of length \( \leq k \) that can be derived from \( A \). For terminals, \( \text{FIRST}_k(a) = \{a\} \) (or prefixes of length \( k \)).
     2. Compute $\text{FOLLOW}_k$ sets: For each nonterminal \( A \), compute the set of strings of length \( \leq k \) that can follow \( A \) in a derivation.
     3. Construct the LL(k) parsing table: For each production \( A \to \alpha \), compute the lookahead sets as \( \text{FIRST}_k(\alpha \cdot \text{FOLLOW}_k(A)) \). Place the production in the table at \( [A, t] \) for each terminal string \( t \) in the lookahead set.
     4. Check for conflicts: The grammar is LL(k) if the parsing table has no conflicts (i.e., no cell \( [A, t] \) contains multiple productions).
     5. Test for each \( k \): If the table has conflicts for \( k = 1 \), try \( k = 2 \) or \( k = 3 \). If conflicts persist, the grammar is not LL(k) for the tested \( k \).
     - For k = 0: LL(0) grammars are rare and require each nonterminal to have a single production with distinct terminals in its derivation. Check if the grammar is essentially deterministic without lookahead.
   Proof: If the table is conflict-free for some \( k \), the grammar is LL(k). Provide the parsing table as evidence. If conflicts exist for all \( k \leq 3 \), state the conflicting entries to prove it’s not LL(k).

\textbf{Check for LR(k)}
   A grammar is LR(k) if it can be parsed bottom-up with \( k \) lookahead symbols using a deterministic LR parsing table based on the canonical collection of LR(k) items.
   Steps:
     1. Construct the LR(k) item sets: An LR(k) item is of the form \( [A \to \alpha \cdot \beta, w] \), where \( \alpha \) is the part already parsed, \( \beta \) is the remaining part, and \( w \) is a lookahead string of length \( k \). Build the DFA of LR(k) items (states) using closure and goto operations.
     2. Build the parsing table: For each state, define actions (shift, reduce, accept) based on the items:
        - Shift: If \( [A \to \alpha \cdot a \beta, w] \) and \( \text{goto}(I, a) = J \), add a shift to state \( J \).
        - Reduce: If \( [A \to \alpha \cdot, w] \), add a reduce by \( A \to \alpha \) for lookahead \( w \).
        - Accept: If \( [S' \to S \cdot, \epsilon] \) (augmented start symbol), accept on end-of-input.
     3. Check for conflicts: The grammar is LR(k) if there are no shift-reduce or reduce-reduce conflicts in the table.
     4. Test for each \( k \): Start with \( k = 0 \). If conflicts arise, try \( k = 1, 2, 3 \). Larger \( k \) resolves conflicts by distinguishing lookaheads.
     - For k = 0: Use empty lookaheads (\( w = \epsilon \)). Conflicts are common, as LR(0) is restrictive.
   - Proof: If the table is conflict-free for some \( k \), the grammar is LR(k). Show the DFA and table. If conflicts exist, list them to prove it’s not LR(k).

\textbf{Check for SLR(k)}
   SLR(k) is a simplified version of LR(k) that uses FOLLOW sets for lookaheads instead of precise LR(k) lookaheads, making it less powerful but easier to compute.
   - Steps:
     1. Build the LR(0) DFA: Construct the DFA of LR(0) items (same as LR(k) but with no lookahead, i.e., \( k = 0 \)).
     2. Compute $\text{FOLLOW}_k$ sets: For each nonterminal \( A \), compute the set of terminal strings of length \( \leq k \) that can follow \( A \).
     3. Construct the SLR(k) parsing table:
        - Shift and goto actions are the same as in LR(0).
        - For an item \( [A \to \alpha \cdot] \) in state \( I \), add a reduce by \( A \to \alpha \) for each terminal string \( t \in \text{FOLLOW}_k(A) \).
     4. Check for conflicts: The grammar is SLR(k) if the table has no shift-reduce or reduce-reduce conflicts.
     5. Test for each \( k \): Try \( k = 0, 1, 2, 3 \). SLR(0) uses empty lookaheads, often leading to conflicts.
   - Proof: If conflict-free, the grammar is SLR(k); provide the table. If conflicts exist, show conflicting actions to prove it’s not SLR(k).

\textbf{Check for LALR(k)}
   - Definition: LALR(k) is a compromise between SLR(k) and LR(k), using the LR(0) DFA but with lookaheads computed by merging LR(k) states.
   - Steps:
     1. Build the LR(0) DFA: Same as for SLR(k).
     2. Compute LALR(k) lookaheads: Propagate lookaheads through the LR(0) DFA to compute the set of lookahead strings of length \( \leq k \) for each item \( [A \to \alpha \cdot] \). This is done by analyzing spontaneous generation and propagation of lookaheads (a simplified version of LR(k) lookaheads).
     3. Construct the LALR(k) parsing table:
        - Shift and goto actions are identical to LR(0).
        - For an item \( [A \to \alpha \cdot, w] \), add a reduce by \( A \to \alpha \) for lookahead \( w \).
     4. Check for conflicts: The grammar is LALR(k) if the table has no conflicts.
     5. Test for each \( k \): Try \( k = 0, 1, 2, 3 \). LALR(0) is equivalent to SLR(0) in practice, as lookaheads are minimal.
   - Proof: If conflict-free, the grammar is LALR(k); show the table and lookaheads. If conflicts exist, list them to prove it’s not LALR(k).

\textbf{Relationships and Optimization}
   - Hierarchy: If a grammar is LR(k), it is LALR(k). If it is LALR(k), it is SLR(k). If it is LL(k), it is not necessarily LR(k), but LL(k) grammars are often simpler. Use this to optimize checks:
     - If the grammar is not SLR(k), it cannot be LALR(k) or LR(k).
     - If it is LR(k), it is also LALR(k) and SLR(k).
     - If it is LL(k), it may still need separate checks for LR-based parsers.
   - Start with k = 1: Most practical grammars are tested for \( k = 1 \). \( k = 0 \) often fails due to insufficient lookahead, and \( k > 1 \) is rarely needed for well-designed grammars.

\textbf{Document the Proof}
   - For each type (LL, SLR, LALR, LR) and each \( k \), provide:
     - The parsing table or DFA (as applicable).
     - Any conflicts found (e.g., specific table entries with multiple actions).
     - A conclusion: “The grammar is [type](k) because the table is conflict-free” or “The grammar is not [type](k) due to conflicts at [state/entry].”

Notes
For k = 0: LL(0) and SLR(0)/LALR(0) are restrictive and rarely practical. Focus on \( k = 1 \) unless specified.
Ambiguity: If the grammar is ambiguous, it fails all tests. Check this first to avoid unnecessary work.
