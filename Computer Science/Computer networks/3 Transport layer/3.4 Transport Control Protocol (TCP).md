## 3.4.1 TCP Connection
### Full-duplex Service
- **TCP Connection**: Provides full-duplex service, allowing simultaneous data flow from Process A to Process B and vice versa.
- **Point-to-Point**: Always between a single sender and a single receiver.
- **Multicasting**: Not possible with TCP; designed for one-to-one communication.
### Data Transmission
#### Sending Data from Client to Server
- **Data Transmission**: Data passes through the socket to TCP in the client.
- **Send Buffer**: TCP directs data to the connection's send buffer.
- **Buffered Data Transmission**: TCP sends data in segments at its own convenience.
- **Maximum Segment Size (MSS)**: Determined by MTU and TCP/IP header length.
- **MTU and MSS**: MTU typically set to 1,500 bytes, resulting in an MSS of 1460 bytes.
- **TCP Segments**: Each chunk of client data paired with a TCP header to form TCP segments.
- **Network Layer**: Segments encapsulated within network-layer IP datagrams and sent into the network.
#### Receiving Data at the Server
- **Receive Buffer**: Data from the received segment stored in the TCP connection's receive buffer.
- **Application Reading**: Application reads the stream of data from the receive buffer.
- **Buffer Separation**: Each side of the connection has its own send and receive buffers.

![[Screenshot 2024-03-21 at 16.07.39.png]]

## 3.4.2 TCP Segment Structure
### Header Fields and Data Field
- **TCP Segment**: Comprises header fields and a data field.
- **Data Field**: Contains a chunk of application data.
- **MSS Limitation**: Determines the maximum size of a segment's data field.
### Transmission of Large Files
- **Chunking**: TCP breaks large files, like images in web pages, into chunks of size MSS.
- **Last Chunk**: The final chunk is often smaller than MSS.
### Interactive Applications
- **Data Chunk Size**: Interactive applications, like Telnet and SSH, often transmit data chunks smaller than MSS.
- **Example**: In remote login applications, such as Telnet and SSH, the TCP segment's data field can be as small as one byte.

![[Screenshot 2024-03-21 at 16.08.39.png]]

### Common Header Fields (Similar to UDP)
- **Source and Destination Port Numbers**: Used for multiplexing/demultiplexing data.
- **Checksum Field**: Similar to UDP, used for error detection.
### Additional TCP Segment Header Fields

#### Sequence and Acknowledgment Fields
- **Sequence Number**: 32-bit field used by TCP sender for reliable data transfer.
- **Acknowledgment Number**: 32-bit field used by TCP receiver to acknowledge received data.
#### Receive Window Field
- **Receive Window**: 16-bit field for flow control, indicating the number of bytes the receiver can accept.
#### Header Length Field
- **Header Length**: 4-bit field specifying TCP header length in 32-bit words, typically 20 bytes.
#### Options Field
- **Options Field**: Optional and variable-length field for negotiating MSS, window scaling, and timestamping.
#### Flag Field
- **Flag Field**: Contains 8 bits:
  - **ACK Bit**: Indicates the acknowledgment field's validity.
  - **RST, SYN, and FIN Bits**: Used for connection setup and teardown.
  - **CWR and ECE Bits**: Used in explicit congestion notification.
  - **PSH Bit**: Indicates immediate data delivery to upper layer.
  - **URG Bit**: Indicates urgent data in the segment.
  - **Urgent Data Pointer Field**: Indicates the location of the last byte of urgent data.
### Practical Considerations
- **PSH, URG, and Urgent Data Pointer**: Often not used in practice.

## 3.4.3 TCP Data Stream
### Sequence Numbers
- **View of Data**: TCP sees data as an ordered stream of bytes.
- **Sequence Numbering**: Assigned over the stream of transmitted bytes, not segments.
- **Example**: Each byte in the data stream is implicitly numbered.
  - **Segment Numbering**: Segments constructed based on sequence numbers.
  - **Example Segment**: First byte has sequence number 0, second has 1,000, and so forth.
### Acknowledgment Numbers
- **Full-Duplex Communication**: Host A may receive data while sending to Host B.
- **Acknowledgment Number**: Indicates the next expected byte from Host B.
- **Example**: If Host A expects byte 536, it puts 536 in the acknowledgment field.
- **Cumulative Acknowledgments**: TCP acknowledges bytes up to the first missing byte.
### Handling Out-of-Order Segments
- **Scenario**: Segments may arrive out of order in a TCP connection.
- **TCP RFCs**: Do not impose rules; leave the decision to programmers.
- **Options**:
  1. Immediate discard of out-of-order segments.
  2. Keep out-of-order bytes, waiting for missing bytes to fill gaps.
- **Efficiency**: Latter choice is more efficient in terms of network bandwidth and is commonly practiced.

![[Screenshot 2024-03-21 at 16.12.27.png]]

## 3.4.5 TCP Connection Establishment
### Step 1: Client Initiates Connection
- **Client Request**: Informs its TCP of the intention to establish a connection with the server.
- **SYN Segment**: Client TCP sends a special segment to the server with the SYN bit set to 1.
- **Initial Sequence Number (ISN)**: Client randomly chooses ISN and includes it in the segment.
### Step 2: Server Acknowledges Connection
- **Server Response**: Extracts SYN segment, allocates TCP buffers, and sends a connection-granted segment (SYNACK).
- **SYNACK Segment**: Contains SYN bit set to 1, acknowledgment of client ISN + 1, and server's own ISN.
### Step 3: Client Acknowledges Server's Response
- **Client Acknowledgment**: Allocates buffers, sends acknowledgment segment with SYN bit set to 0.
- **Acknowledgment Segment**: Contains acknowledgment of server's ISN + 1.
- **Established Connection**: Allows data exchange between client and server.
### Three-Way Handshake
- **Procedure**: Three packets exchanged between hosts to establish the connection.
- **Purpose**: Ensures synchronisation and agreement on initial sequence numbers.
- **SYN Bit**: Set to zero in subsequent segments after connection establishment.

![[Screenshot 2024-03-21 at 16.14.21.png]]
## 3.4.6 TCP Connection Termination

### Closing the Connection
- **Either Process**: Can initiate the closure of the TCP connection.
- **Client Close Command**: Results in sending a special segment with the FIN bit set to 1.
- **Server Response**: Acknowledges the client's segment and sends its own shutdown segment.
- **Acknowledgment**: Client acknowledges the server's shutdown segment.
- **Resource Deallocation**: Buffers and variables in hosts are deallocated after acknowledgment.

![[Screenshot 2024-03-21 at 16.14.43.png]]
## 3.4.7 TCP Timeout/Retransmit Mechanism
### Timeout Interval Considerations
- **Recovery from Lost Segments**: TCP utilises a timeout/retransmit mechanism.
- **Subtle Issues**: Arise when implementing the mechanism in TCP.
### Estimation of Round-Trip Time (RTT)
- **RTT Estimation**: Critical for determining timeout intervals.
- **Sample RTT (SampleRTT)**: Time between segment transmission and acknowledgment receipt.
  - **Measurement**: Taken for only one unacknowledged segment at a time.
  - **Exclusion**: No SampleRTT computation for retransmitted segments.
  
- **Estimated RTT (EstimatedRTT)**: Weighted average of SampleRTT values.
  - **Formula**: $EstimatedRTT = (1 - α) * EstimatedRTT + α * SampleRTT$
  - **Weighting**: Recent samples receive more weight, reflecting current network congestion.
  - **Exponential Weighted Moving Average (EWMA)**: Statistical term for this weighted average.
  
- **RTT Variation (DevRTT)**: Estimate of SampleRTT deviation from EstimatedRTT.
  - **Formula**: $DevRTT = (1 - β) * DevRTT + β * |SampleRTT - EstimatedRTT|$
  - **Recommended Values**: α = 0.125, β = 0.25 according to RFC 6298.

![[Screenshot 2024-03-21 at 16.17.10.png]]

## 3.4.8 Determining TCP Timeout Interval
### Considerations
- **Greater than EstimatedRTT**: To avoid unnecessary retransmissions.
- **Not Too Much Larger**: To ensure timely retransmission of lost segments.
- **Margin**: Added to EstimatedRTT to set the timeout interval.
- **Dependence on DevRTT**: Determines the size of the margin.
### Method for Timeout Interval
- **Formula**: $TimeoutInterval = EstimatedRTT + 4 * DevRTT$

- **Initial Value**: Recommended initial TimeoutInterval is 1 second (RFC 6298).
- **Doubling on Timeout**: TimeoutInterval doubled on timeout to prevent premature timeouts for subsequent segments.
- **Recalculation**: Upon segment reception and EstimatedRTT update, TimeoutInterval is recalculated using the above formula.

![[Screenshot 2024-03-21 at 16.18.38.png]]

## 3.4.9 TCP Timer Management
### Single Retransmission Timer
- **Theory vs. Overhead**: While associating individual timers with each unacknowledged segment is conceptually simple, it incurs considerable overhead.
- **Recommended Procedure**: TCP follows RFC 6298 recommendation of using a single retransmission timer.
### Major Events in TCP Sender
1. **Data Received from Application**: TCP encapsulates data into segments and passes them to IP.
   - **Sequence Number**: Assigned to each segment, representing the byte-stream number of the first data byte.
   - **Timer Management**: Timer starts upon segment transmission if not already running.
   - **Timer Expiration**: TimeoutInterval calculated from EstimatedRTT and DevRTT.

2. **Timer Timeout**: Occurs if the retransmission timer expires.
   - **Action**: TCP retransmits the segment that caused the timeout and restarts the timer.

3. **ACK Receipt**: Arrival of acknowledgment segment from the receiver.
   - **Comparison with SendBase**: TCP compares the ACK value with SendBase.
     - **SendBase**: Sequence number of the oldest unacknowledged byte.
   - **Cumulative Acknowledgments**: If ACK > SendBase, sender updates SendBase and restarts the timer for any remaining unacknowledged segments.

![[Screenshot 2024-03-21 at 16.20.32.png]]



## 3.4.10 TCP Receiver's ACK Generation Policy

- **Gap Detection**: Occurs when received segment's sequence number exceeds the next expected in-order sequence number.
- **Response**: Various actions depending on the scenario:
  - **Delayed ACK**: Wait up to 500ms for another in-order segment, else send ACK.
  - **Immediate ACK**: Send ACK immediately in certain scenarios.
  - **Cumulative ACK**: Send a single ACK for multiple in-order segments together.
  - **Duplicate ACK**: Sent immediately upon arrival of out-of-order segment.
- **Negative Acknowledgments**: Not used in TCP; instead, duplicate ACKs are sent for missing segments.
## 3.4.11 TCP Fast Retransmit

- **Problem with Timeout-triggered Retransmissions**:
  - Long timeout period leads to increased end-to-end delay.
  - Sender delays resending lost packet until timeout event occurs.

- **Detection of Packet Loss**:
  - Utilises duplicate ACKs to detect packet loss before timeout.
  - Duplicate ACK: Re-acknowledges a segment for which the sender has already received an earlier acknowledgment.

- **Fast Retransmit Mechanism**:
  - Triggered by the reception of three duplicate ACKs for the same data.
  - Indicates likely loss of the following segment.
  - TCP sender performs a fast retransmit, retransmitting the missing segment before its timer expires.

- **Advantages**:
  - Helps in reducing end-to-end delay by avoiding waiting for timeout.
  - Provides a quicker response to packet loss based on immediate feedback from the network.

![[Screenshot 2024-04-04 at 10.15.08.png]]

## 3.4.12 TCP Error Recovery: Hybrid Approach

- **Hybrid of Go-Back-N and Selective Repeat**
  - Combines features of both approaches.
### Similarities with Go-Back-N
- **Cumulative Acknowledgments**
- **Out-of-Order Segment Handling**
  - Not individually ACKed
- **Sender State**
  - Maintains SendBase and NextSeqNum
### Differences from Go-Back-N
- **Buffering of Out-of-Order Segments**
  - Most TCP implementations buffer received out-of-order segments.
- **Selective Retransmission**
  - TCP does not retransmit all unacknowledged segments if acknowledgment is received before the next timeout.
### Similarities with Selective Repeat
- **Proposed TCP Modification**
  - Selective acknowledgment [RFC 2018] allows TCP to acknowledge out-of-order segments selectively.

## 3.4.13 TCP Flow Control

### Concept
- **Preventing Buffer Overflow**
  - Sender's rate matched against receiver's reading speed.

### Mechanism: Receive Window
- **Definition**: Indicates free buffer space available at receiver.
- **Full-Duplex**: Maintained by sender at each side of the connection.
- **Variables**
  - LastByteRead: Last byte read by application process in receiver.
  - LastByteRcvd: Last byte received and placed in receive buffer.
- **Constraint**: Prevent buffer overflow
  $LastByteRcvd - LastByteRead ≤ RcvBuffer$
 
- **Dynamic Value**: Adjusted as buffer space changes. 
  $rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)$
### Flow Control Service
- **Communication**
  - Host B informs Host A about spare buffer space by placing rwnd in receive window field of segments sent to A.
- **Initialisation**
  - Initially set to RcvBuffer.
- **Management**
  - Host B tracks connection-specific variables to maintain rwnd accurately.

![[Screenshot 2024-04-04 at 10.18.55.png]]


## 3.4.14 Host A's Flow Control Management

### Variables Tracking
- **LastByteSent**: Last byte sent by Host A into the connection.
- **LastByteAcked**: Last byte acknowledged by Host B.

### Control Mechanism
- **Ensuring Buffer Safety**
  - Keep unacknowledged data sent by A less than or equal to rwnd.  
  $LastByteSent - LastByteAcked ≤ rwnd$
### Handling Zero Receive Window (rwnd = 0)
- **Issue**: B's receive buffer is full (rwnd = 0) and has nothing to send.
- **Problem**: Host A is unaware of buffer space availability, hence cannot send more data.
- **Solution**: Host A continues to send segments with one data byte.
  - Segments will be acknowledged by B, indicating buffer space availability.
- **Result**: Eventually, buffer will empty, acknowledgments will contain nonzero rwnd value, allowing A to resume transmission.

![[Screenshot 2024-04-04 at 10.21.14.png]]
