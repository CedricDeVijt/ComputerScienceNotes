## 1.1 Why and What of Software Engineering

### 1.1.1 Definition of Software Engineering

- **"State of the art of developing quality software on time and within budget."**
  - Trade-off between perfection and physical constraints.
  - Requires lifelong learning as best practices evolve.
- **"Multi-person construction of multi-version programs."**
  - Emphasizes teamwork and adaptability.
  - Software systems must evolve or perish.
- **"Different from other engineering disciplines."**
  - Not constrained by physical laws; influenced by human and political factors.

### 1.1.2 Key Questions in Software Development

1. Where do specifications come from?
2. How to ensure specifications match user needs?
3. How to structure programs effectively?
4. Ensuring the program meets the specifications.
5. Addressing changing user needs.
6. Collaborating in multi-person teams.

## 1.2 Software Product and Process

### 1.2.1 What is a Software Product?

- Delivered to the customer.
- Includes:
  - Requirements Specification.
  - System implementation.
  - Documentation and manuals.

### 1.2.2 What is a Software Process?

- **Definition**: Collection of activities leading to a product.
- **Evaluation Criteria**:
  - **Correctness**:
    - Are we building the right product? (Validation)
    - Are we building the product right? (Verification)
  - **Traceability**:
    - Can we identify which product components are affected by changes?

## 1.3 Software Development Lifecycles

### 1.3.1 Waterfall Model

- **Advantages**:
  - Clear visibility and control over progress.
  - Useful for bidding and contract negotiations.
- **Disadvantages**:
  - Unrealistic for large projects.
  - Difficult and costly to adapt to requirement changes.

### 1.3.2 Iterative and Incremental Development

- **Iterative Development**:
  - Reworking parts to improve them.
  - Encourages learning through experimentation.
- **Incremental Development**:
  - Progress in small steps.
  - Always have a running version for validation.

## 1.4 Risk Management in Software Engineering

### 1.4.1 Risk Analysis Process

1. **Risk Identification**: Using a checklist to identify risks.
   - Examples: staffing risk, technical challenges, market demand.
2. **Risk Projection**: Estimating likelihood and impact.
   - Likert scales for impact and likelihood.
3. **Risk Assessment**:
   - Prioritize important risks based on appetite.
   - Develop mitigation strategies.

### 1.4.2 Risk Projection Formula

- **Risk = Impact \* Likelihood**
- Incorporates urgency when needed:
  - Less time = higher risk priority.

### 1.4.3 Failure Mode and Effects Analysis (FMEA)

- **Definition**: Identifying potential failures and their impact.
- **Failure Modes**:
  - **Failure**: Any deviation from the expected behavior.
  - **Failure Mode**: Specific way a failure can occur.
- **Effects Analysis**:
  - **Impact**: Consequences of a failure.
  - **Severity**: Degree of impact on the system.
- **Steps**:
  1. Identify potential failures.
  2. Analyze the impact of each failure.
  3. Prioritize failures based on risk.
  4. Develop mitigation strategies.

## 1.5 Agile and Extreme Programming

### 1.5.1 Agile Principles

- Values:
  1. Individuals and interactions over processes and tools.
  2. Working software over comprehensive documentation.
  3. Customer collaboration over contract negotiation.
  4. Responding to change over following a plan.

### 1.5.2 Extreme Programming (XP)

- **Core Practices**:
  - Pair programming, test-driven development, and continuous integration.
  - Small releases and collective code ownership.
- **Key Values**:
  - Sustainable pace, coding standards, and customer involvement.

### 1.5.3 Scrum

- **Structure**:
  - Sprint: 2-4 week iterations creating a working product increment.
  - Daily stand-ups and reviews.
- **Roles**:
  - Product Owner: Prioritize backlog.
  - Scrum Master: Facilitate team.
  - Development Team: Build the product increment.

## 1.6 Unified Modeling Language (UML)

### 1.6.1 Static UML

- **Class Diagrams**:
  - Represent classes, attributes, and operations.
  - Highlight relationships like inheritance and associations.
- **Aggregation vs. Composition**:
  - Aggregation: Whole-part relationship; parts can exist independently.
  - Composition: Parts cannot exist without the whole.

### 1.6.2 Dynamic UML

- **Sequence Diagrams**:
  - Show object interactions over time.
- **Collaboration Diagrams**:
  - Show associations and messages between objects.

---

## Key Points to Remember

- Software engineering focuses on teamwork, adaptability, and evolution.
- Evaluation criteria: Correctness (validation and verification) and traceability.
- Waterfall model provides structure but lacks flexibility for changes.
- Agile promotes responsiveness and collaboration through iterative development.
- Extreme Programming emphasizes testing, refactoring, and continuous integration.
- Risk management requires identifying, estimating, and mitigating potential issues.
- UML serves as a standard for visualizing and modeling software systems.
