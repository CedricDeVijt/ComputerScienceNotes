## 5.2.1 Error Detection and Correction at Sending and Receiving Nodes
### Sending Node
- **Data Augmentation**: Data, D, is augmented with error-detection and -correction bits (EDC).
- **Protected Data**: Includes datagram from the network layer, link-level addressing information, sequence numbers, and other frame header fields.
- **Transmission**: Both D and EDC are sent to the receiving node in a link-level frame.
### Receiving Node
- **Received Sequence**: Receives a sequence of bits, D and EDC, which may differ from the original due to in-transit bit flips.
- **Receiver's Challenge**: Determine if D matches the original D, given only D and EDC.
- **Decision Wording**: Receiver's decision focuses on error detection rather than error occurrence.
- **Error Detection Limitations**: Techniques may detect errors sometimes, but not always.
- **Undetected Bit Errors**: Possibility of undetected bit errors despite error-detection bits.
- **Consequences**: Corrupted datagram delivery to the network layer or unawareness of corrupted header field contents.
- **Choosing Error-Detection Scheme**: Aim to minimise the probability of undetected bit errors.
- **Trade-offs**: More sophisticated techniques incur larger overhead due to increased computation and transmission of error-detection and -correction bits.

![[Screenshot 2024-05-02 at 11.31.36.png]]

## 5.2.2 Single Parity Bit Error Detection
### Overview
- **Simplest Form**: Single parity bit used for error detection.
- **Even Parity Scheme**: Total number of 1s in the d + 1 bits (original information plus parity bit) is even.
- **Odd Parity Scheme**: Total number of 1s in the d + 1 bits is odd.
### Sender Operation
- **Parity Bit Calculation**: Sender includes one additional bit to ensure even or odd parity.
### Receiver Operation
- **Parity Bit Check**: Receiver counts the number of 1s in the received d + 1 bits.
- **Detection of Errors**: Odd number of 1-valued bits indicates at least one bit error.

![[Screenshot 2024-05-02 at 11.33.37.png]]
### Limitations
- **Even Number of Bit Errors**: Results in undetected error.
- **Probability Consideration**: Small probability of multiple bit errors assumed to occur independently.
- **Burst Error Conditions**: Errors are often clustered together in bursts rather than occurring independently.
- **Impact on Error Detection**: Under burst error conditions, probability of undetected errors can approach 50%. 
### Need for Robust Scheme
- **Practical Usage**: Measurements show the necessity for a more robust error-detection scheme.
- **Practical Implementation**: Robust error-detection schemes are used in practice to mitigate the limitations of single parity bit detection.

## 5.2.3 Two-Dimensional Parity Scheme
### Generalisation of Single-Bit Parity
- **Extension**: Two-dimensional version of single-bit parity scheme.
- **Division of Bits**: d bits in D divided into i rows and j columns.
- **Parity Computation**: Parity value computed for each row and each column.
- **Total Error-Detection Bits**: i + j + 1 parity bits in the link-layer frame.

![[Screenshot 2024-05-02 at 11.35.21.png]]
### Error Detection and Correction
- **Single Bit Error Occurrence**: 
  - Parity of both the column and the row containing the flipped bit will be in error.
- **Detection and Correction**: 
  - Receiver can detect the occurrence of a single bit error.
  - Receiver can identify the corrupted bit using the column and row indices of the parity errors.
  - **Forward Error Correction (FEC)**: Ability of the receiver to both detect and correct errors.
### Significance of FEC
- **Enhanced Error Handling**: FEC allows for both detection and correction of errors.
- **Efficiency**: Increases the reliability of data transmission by addressing errors at the receiver end.
- **Applications**: Commonly used in various communication systems to improve reliability and performance.

## 5.2.4 Checksumming Techniques
### Overview
- **Treatment of Data**: d bits of data treated as a sequence of k-bit integers.
- **Simple Checksum Method**: Summing these k-bit integers to form error-detection bits.
- **Internet Checksum**: Example of this approach, treating bytes of data as 16-bit integers and summing them. The 1s complement of this sum is used as the checksum in the segment header.
### Checksum Calculation and Verification
- **Checksum Calculation**:
  - Sum of the k-bit integers forms the checksum.
- **Checksum Verification**:
  - Receiver computes the 1s complement of the sum of the received data (including the checksum).
  - Checks whether the result is all 0 bits to detect errors.
### Protocol-Specific Usage
- **TCP and UDP**: Checksum computed over all fields (header and data fields included).
- **IP**: Checksum computed over the IP header only (since UDP or TCP segment has its own checksum).
- **Other Protocols** (e.g., XTP):
  - One checksum computed over the header.
  - Another checksum computed over the entire packet.
### Comparison with CRC
- **Packet Overhead**: Checksums require relatively little overhead (e.g., TCP and UDP checksums use only 16 bits).
- **Weakness**: Provide relatively weak protection against errors compared to cyclic redundancy check (CRC).
### Usage at Transport vs. Link Layer
- **Transport Layer Usage**:
  - Implemented in software in the host's operating system.
  - Importance of simple and fast error-detection scheme (e.g., checksumming).
- **Link Layer Usage**:
  - Implemented in dedicated hardware in adapters.
  - Rapid performance of more complex CRC operations is feasible.
## 5.2.6 Cyclic Redundancy Check (CRC) Codes
### Overview
- **Also Known As**: Polynomial codes.
- **Bit String Representation**: The data to be sent is viewed as a polynomial, with coefficients as the 0 and 1 values in the bit string, and operations interpreted as polynomial arithmetic.
### Operation of CRC Codes
- **Generator Pattern**: Agreed upon by sender and receiver, denoted as G, with r + 1 bits.
  - Most significant bit of G must be 1.
- **Data Transmission**:
  - Sender appends r additional bits, denoted as R, to the d-bit data D.
  - Resulting d + r bit pattern must be exactly divisible by G using modulo-2 arithmetic (no remainder).
- **Error Detection**:
  - Receiver divides the received d + r bits by G.
  - If remainder is nonzero, error is detected; otherwise, data is accepted as correct.
### Modulo-2 Arithmetic
- **Characteristics**:
  - No carries in addition or borrows in subtraction.
  - Addition and subtraction are identical and equivalent to bitwise exclusive-or (XOR).
  - Multiplication and division are similar to base-2 arithmetic but without carries or borrows.
### Standards
- Standards have been defined for 8-, 12-, 16-, and 32-bit CRC generators

